{"meta":{"title":"YoungHeaKim's Blog","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Fork 뜬 후 Branch 만들기","slug":"git(fork)","date":"2017-08-23T09:54:10.000Z","updated":"2017-09-23T12:51:00.000Z","comments":true,"path":"2017/08/23/git(fork)/","link":"","permalink":"http://yoursite.com/2017/08/23/git(fork)/","excerpt":"","text":"fork 뜨는 법사진의 오른쪽 상단에 fork버튼을 누른다. 내 컴퓨터와 연결하는 법 clone을 누른후 밑의 주소를 복사 후 터미널에서 명령어를 친다. 1git clone (자신의 github에서 clone 주소) 터미널에서 클론이 된 폴더로 들어간다. 1cd (폴더명) 터미널에서 연결이 되었는지 확인을 한다. 1git remote -v 이 때의 결과창은 밑의 코드와 같이 나온다.12origin https://github.com/YoungHeaKim/til.git (fetch)origin https://github.com/YoungHeaKim/till.git (push) fork를 뜬 사람의 주소로 들어간 후 clone주소를 복사한다. 1git remote add (fork 뜬 사람의 별명) (fork 뜬 사람의 주소) 연결이 잘 되어 있는 지 확인을 한다. 1git remote -v 결과는1234origin https://github.com/YoungHeaKim/to-do-list.git (fetch)origin https://github.com/YoungHeaKim/to-do-list.git (push)upstream https://github.com/seultt/to-do-list.git (fetch)upstream https://github.com/seultt/to-do-list.git (push) 파일을 올릴 때는 2가지 방법이 있다. 첫번째 방법 add, commit을 한 후 자신의 github에 올린 후 pull-request를 보낸다.1git push origin (branch 이름) 두번째 방법 add, commit을 한 후 포크를 떠 온 사람의 github로 바로 pull-request를 보낸다. 1git push -set--(포크해온 사람의 별칭) (branch 이름) pull을 할 경우1git pull (fork 뜬 사람의 별명) (branch 이름) 다른 사람이 자신의 repository를 fork해간 경우 clone을 한 후 1git clone (자신의 repository 주소) 터미널에서 해당 폴더로 이동 한다. 1cd (폴더 이름) fork를 떠간 사람과 연결해야 하기 위해 1git remote add (fork해간 사람의 repo주소) push를 방법 1git push origin (branch 이름) pull을 할 경우 1git pull origin (branch 이름)","categories":[{"name":"GIT","slug":"GIT","permalink":"http://yoursite.com/categories/GIT/"},{"name":"FORK","slug":"GIT/FORK","permalink":"http://yoursite.com/categories/GIT/FORK/"}],"tags":[{"name":"GIT","slug":"GIT","permalink":"http://yoursite.com/tags/GIT/"},{"name":"FORK","slug":"FORK","permalink":"http://yoursite.com/tags/FORK/"},{"name":"BRANCH","slug":"BRANCH","permalink":"http://yoursite.com/tags/BRANCH/"}]},{"title":"Passport","slug":"passport","date":"2017-08-19T09:54:10.000Z","updated":"2017-09-23T12:57:13.000Z","comments":true,"path":"2017/08/19/passport/","link":"","permalink":"http://yoursite.com/2017/08/19/passport/","excerpt":"","text":"WPSN PassportPassport는 다양한 인증 수단을 지원할 수 있도록 추상화된 인증 미들웨어입니다. StrategyPassport는 인증 절차를 정의하기 위해 strategy라는 개념을 사용특정 인증 방식에 대해 정해진 방식대로 strategy를 구현하기만 하면, express와 같은 웹 서버와 쉽게 연동할 수 있다.1234567891011121314151617// passport가 \"사용자 이름과 암호 기반 인증\"을 수행하도록 strategy 등록passport.use(new LocalStrategy((username, password, done) =&gt; &#123; query.compareUser(username, password) .then(user =&gt; &#123; // 인증 성공 done(null, user) &#125;) .catch(err =&gt; &#123; if (err instanceof query.LoginError) &#123; // 인증 실패: 사용자 책임 done(null, false, &#123;message: err.message&#125;) &#125; else &#123; // 인증 실패: 서버 책임 done(err) &#125; &#125;)&#125;)) passport에서 인증이 성공할 때는 done(null,user)를 사용하면 passport로 넘어가 다음으로 진행을 해준다.compareUser는 우리가 직접 만들어 주어야 한다. passport.authenticate()strategy를 이용해 passport가 인증을 위한 라우트 핸들러를 생성하게 할 수 있다.123456// passport-local을 통해 생성한 라우트 핸들러app.post('/login', passport.authenticate(('local'), &#123; successRedirect: '/', // 인증 성공 시 리다이렉트시킬 경로 failureRedirect: '/login', // 인증 실패 시 리다이렉트시킬 경로 failureFlash: '아이디 혹은 패스워드가 잘못되었습니다.' // 인증 실패 시 표시할 메시지&#125;)) flash를 사용하여 메세지도 보여줄 수 있다.strategy마다 한번씩 써주어야 한다. serializeUser, deserializeUser프로그램 상의 어떤 객체를 바이너리 혹은 텍스트의 형태로 변환하는 작업을 직렬화(serialization), 그 반대를 역직렬화(deserialization)라고 합니다.직렬화 - 객체를 문자열로 바꿔주는 작업역직렬화 - 문자열을 객체로 바꿔주는 작업위의 passport와 다르게 이 두개는 한번만 사용해주면 된다.12345678910111213141516// passport가 유저 정보를 세션에 저장할 수 있도록 직렬화passport.serializeUser((user, done) =&gt; &#123; done(null, user.id)&#125;)// passport가 세션으로부터 유저 객체를 가져올 수 있도록 역직렬화passport.deserializeUser((id, done) =&gt; &#123; query.getUserById(id) .then(user =&gt; &#123; if (user) &#123; done(null, user) // req.user에 저장됨 &#125; else &#123; done(new Error('해당 아이디를 가진 사용자가 없습니다.')) &#125; &#125;)&#125;) 장점은 나중에 strategy를 추가할때 좋다. req.login, req.logout위의 authenticate()에서 로그인을 되게 해주지만 req.login메소드는 회원 가입 이후에 자동으로 로그인을 시켜주려는 목적으로 사용되고 req.logout메소드는 현재 세션에 들어있는 인증 정보를 지우고 로그아웃을 시키는 메소드이다.12345678910111213141516171819202122// loginapp.post('/register', (req, res, next) =&gt; &#123; query.createUser(req.body.username, req.body.password) .then(user =&gt; &#123; // 회원 가입 시 자동으로 로그인 시키고 리다이렉트 req.login(user, err =&gt; &#123; if (err) &#123; next(err) &#125; else &#123; res.redirect('/') &#125; &#125;) &#125;) .catch(util.flashError(req, res))&#125;)// logoutapp.post('/logout', (req, res) =&gt; &#123; // passport가 제공하는 `req.logout` 메소드 req.logout() res.redirect('/login')&#125;) passport.initialize()Express 앱에서 Passport를 사용하기 위해서는 다음과 같이 미들웨어를 주입해주어야 합니다.인증 과정에서 세션을 사용하지 않는다면 passport.session()은 주입하지 않아도 무방합니다.맨위에 써주는 것이다.123// passport 관련 미들웨어 삽입app.use(passport.initialize())app.use(passport.session()) JWT를 사용해주는 경우에는 안써주어도 된다. 쿠키 이름 저장쿠키이름을 저장할 떄 프로젝트마다 다른 이름을 써주어야 나중에 구별하기 쉽다.1234app.use(cookieSession(&#123; name: 'session', keys: ['mysecret']&#125;))","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"로그인 연동","slug":"Node-js/로그인-연동","permalink":"http://yoursite.com/categories/Node-js/로그인-연동/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"passport","slug":"passport","permalink":"http://yoursite.com/tags/passport/"}]},{"title":"OAuth","slug":"oauth","date":"2017-08-19T09:54:10.000Z","updated":"2017-09-23T12:57:27.000Z","comments":true,"path":"2017/08/19/oauth/","link":"","permalink":"http://yoursite.com/2017/08/19/oauth/","excerpt":"","text":"WPSN OAuth최근에 웹을 사용한 경험이 있는 분들은 대부분 “페이스북으로 로그인” 버튼을 한 번 쯤 사용해보셨을 겁니다. 이 때 사용되는 인증 절차가 바로 OAuth입니다.제각각이던 인증 방식을 표준화한 것을 OAuth라고 한다.OAuth를 사용하면 사용자의 아이디와 암호가 노출되지 않도록 하면서도 애플리케이션에 API 접근 권한을 안전하게 위임할 수 있다. OAuth 역할만약 trello에서 google의 로그인을 사용할 때 자원 소유자OAuth를 통해 보호되고 있는 자원을 소유하고 있는 자원의 실제 소유자입니다.웹 애플리케이션의 사용자입니다. 자원 서버사용자 소유의 자원을 제공하는 서버. API 서버라고 봐도 무방합니다. 인증 서버소규모 서비스의 경우 자원 서버와 같은 서버에 위치해있는 경우가 많습니다.인증 서버는 google이 된다. 클라이언트OAuth를 통해 보호되고 있는 자원에 사용자 대신 접근하려고 하는 주체를 말합니다. 보통 자원 서버가 제공하는 API를 사용하려고 하는 웹 애플리케이션 서버를 가리킵니다.클라이언트는 트렐로가 된다. 사용자(자원 소유자)는 웹 애플리케이션(OAuth 클라이언트)에 인증 시작을 위한 요청을 보낸다. 웹 애플리케이션은 인증 서버로 사용자의 웹 브라우저를 리다이렉트 시킨다. (OAuth 클라이언트 정보가 포함됨) 사용자는 인증 서버에서 보여주는 화면을 통해 웹 애플리케이션이 요구하는 권한을 확인하고, 웹 애플리케이션이 본인 대신에 인증 정보를 활용할 수 있도록 허가한다. 인증 서버는 사용자의 웹 브라우저를 다시 웹 애플리케이션으로 리다이렉트 시킨다 (인증 코드 포함, 인증코드를 사용하여 access Token을 준다.) 웹 애플리케이션은 인증 코드를 포함시킨 요청을 인증 서버에 보내고, 액세스 토큰을 응답받는다. 웹 애플리케이션은 이제부터 액세스 토큰을 이용해 자원 서버를 사용할 수 있게 된다. 보통 가장 처음으로 사용자에 대한 정보를 가져온다. 해당 사용자 정보를 이용해 성공적으로 인증이 되었다는 사실을 사용자에게 보여준다. 사용자는 웹 애플리케이션을 통해서 자원 서버에 저장되어 있는 정보를 활용할 수 있게 된다. 우리가 만들 사이트도 사용자 클라이언트 인증서버가 신뢰를 확보하기위해 위의 절차를 거쳐야 한다. OAuth의 scope어떤 정보를 사용자에게 허락을 받을 때 Scope를 사용해준다.google은 큰 회사이기 때문에 원하는 Scope를 하나씩 설정을 해주어야 사용할 수 있다. id암호화새로운 table을 만들고 provider와 provider_user_id를 local로 만들고 그 후에 두개의 테이블을 provider_user_id는 새로만든 table에 id와 연결 시켜주면 된다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"로그인 연동","slug":"Node-js/로그인-연동","permalink":"http://yoursite.com/categories/Node-js/로그인-연동/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"OAuth","slug":"OAuth","permalink":"http://yoursite.com/tags/OAuth/"}]},{"title":"CSRF공격 방어","slug":"csrf","date":"2017-08-18T09:54:10.000Z","updated":"2017-09-23T13:07:19.000Z","comments":true,"path":"2017/08/18/csrf/","link":"","permalink":"http://yoursite.com/2017/08/18/csrf/","excerpt":"","text":"CSRFCross-site Request Forgery: 사이트 간 요청 위조 다른 공격 기법 XSS SQL Injection CSRF 공격 기법어떠한 요청을 img를 찾기위해 GET으로 보내기 때문에 그때 데이터를 조작할 수 있게 만든다.사이트가 다른 곳에서 요청을 보내면 다른 사이트에서 그것의 요청을 잘 받아들이는 것을 볼 수 있다.우리는 쿠키세션을 사용하고 있는데 쿠키는 한번 세팅을 하면 같은 주소에 요청을 보낼 때마다 시키지 않아도 자동으로 쿠키를 포함하여 요청을 보낸다. 해결방안우리 웹사이트에서 정말 보낸 요청이 맞는지를 확인을 해야한다.쿠키 말고도 다른 post 요청을 보내서 확인해야한다.우리 웹사이트에서만 보낼 수 있는 정보(CSRF 토큰)를 post요청을 하면 CSRF의 공격을 방어할 수 있다.단 유저마다 다른 CSRF 토큰을 사용하여야 한다. CSURFCSURF미들웨어를 사용하여 CSRF공격을 방어할 수 있다.사용자가 악의적인 웹 페이지에 접속했을 때 해당 웹 페이지에서 다른 서버로 요청을 보내어 정보를 조작하는 공격 기법입니다.CSRF는 SECRET과 TOCKEN을 만들어 두개의 서로 매칭이 되는지에 대헤 확인을 할수 있다.SECRET - Session에 저장한다.TOKEN - POST Body에 저장을 한다.Secret은 미들웨어를 사용하면 자동으로 Secret과 matching부분을 해주기 때문에 상관없다.그렇지만 POST body부분은 우리가 form작성 시 직접 포함시켜주어야 한다. 사용법1npm install --save csurf 그리고12345const csrfMiddleware = csurf()// 모든 라우터에 적용가능app.use(csrfMiddleware)// 모든 render에 추가&#123;rows, csrfToken: req.csrfToken()&#125; 모든 html에 form태그 안에 작성1&lt;input type=\"hidden\" name=\"_csrf\" value=\"&lt;%= csrfToken %&gt;\"&gt; knex seed file밑의 코드를 써주면 seed폴더안에 파일을 생성해준다.1knex seed:make (seed_name) 위에서 생성해준 파일에 밑의 js파일을 작성해 준다.12345678910111213141516171819202122232425262728const faker = require('faker')const randomstring = require('randomstring')exports.seed = function(knex, Promise) &#123; // Deletes ALL existing entries return knex('user') .insert(&#123; id: 'fast', password: 'campus' &#125;) .then(() =&gt; &#123; const arr = [] for (var i = 0; i &lt; 20; i++) &#123; arr.push( knex('url_entry') .insert(&#123; id: randomstring.generate(8), long_url: faker.internet.url(), user_id: 'fast' &#125;).then(console.log) ) &#125; return Promise.all(arr) &#125;) // promise가 감싸고 있는 값이 밑의 then에 들어간다. // .then(value =&gt; &#123;&#125;)&#125;;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"CSRF 공격 방어","slug":"Node-js/CSRF-공격-방어","permalink":"http://yoursite.com/categories/Node-js/CSRF-공격-방어/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"CSRF","slug":"CSRF","permalink":"http://yoursite.com/tags/CSRF/"}]},{"title":"실시간 대화창(Soket.io)","slug":"soket","date":"2017-08-18T09:54:10.000Z","updated":"2017-09-23T13:09:54.000Z","comments":true,"path":"2017/08/18/soket/","link":"","permalink":"http://yoursite.com/2017/08/18/soket/","excerpt":"","text":"WebSocket클라이언트가 websocket 요청을 보내고 서버가 websocket을 지원하면 websocket의 응답을 보낸다. 이때 응답과 요청은 HTTP인대 연결이 되면 HTTP가 아닌 WebSocket이 되어 요청과 응답을 보낸다.요청을 보낼 때 CONNECTION: Upgrade를 보내고 응답을 Upgrade:websocket라고 답을 한것을 볼수 있다.밑의 content는 많이 사용한다.1DOMContentLoaded emit은 발산시키다라는 의미로 message라는 이벤트를 발산시키고 뒤의 데이터를 포함시켜서 보내는 것이다. HTTP는 내장 모듈로 HTTP의 서버를 만들어 주거나 express와 soket.io를 함께 사용하려면 써주어야 한다.밑에 방식으로 사용을 하여 io를 사용해준다.123const app = express()const server = http.Server(app)const io = socketio(server) 사전 정의된 이벤트 목록 ‘connect’ 혹은 ‘connection’: 클라이언트가 새 연결을 맺었을 때 ‘disconnect’: 클라이언트의 연결이 끊어졌을 때 ‘error’: 에러가 발생했을 때 ‘disconnecting’: 클라이언트가 연결을 끊기 직전에 1const socket = io() 위의 코드를 사용하면 모든 socket은 루트디렉토리로 간다.nameSpace로 가면 디렉토리를 가둬서 사용할 수 있다. socket객체는 서버에서 미리 저장되어 있는 것이다.html에 data-이라는 값을 불러올땐 dataset이라는 것으로 불러올수 있다.command + shift + n 누르면 secret 창이 뜬다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Soket.io","slug":"Node-js/Soket-io","permalink":"http://yoursite.com/categories/Node-js/Soket-io/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Soket.io","slug":"Soket-io","permalink":"http://yoursite.com/tags/Soket-io/"}]},{"title":"원하는 숫자 찾기(JAVASCRIPT)","slug":"js(searchEight)","date":"2017-08-16T09:54:10.000Z","updated":"2017-09-17T10:24:39.000Z","comments":true,"path":"2017/08/16/js(searchEight)/","link":"","permalink":"http://yoursite.com/2017/08/16/js(searchEight)/","excerpt":"","text":"1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기문제1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라. 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. (※ 예를들어 8808은 3, 8888은 4로 카운팅 해야 함) 풀이1234567891011121314151617181920212223242526function searchEight(num) &#123; // 변수의 선언위치가 중요하다. 만약 for문안에 count를 선언해주면 for문이 실행 될 때마다 count=0;으로 초기화가 되기때문에 for문 밖에 써주는 것이 중요하다. var count = 0; // 1부터 10000까지 확인을 해야해서 반복문 사용 for (var numOrd = 1; numOrd &lt;= num; numOrd++)&#123; // num은 숫자형이기 때문에 문자열로 바꿔주고 str은 배열이 아님으로 split메소드를 사용하여 배열로 변화를 줘야함. var numArr = numOrd.toString().split(''); // i는 0부터 10000까지 도는 숫자에서 8을 검색하는 for문을 만듬 for (var i = 0; i &lt; numArr.length; i++)&#123; // numArr[i]를 사용하여 각 자리의 값을 8인지 비교 , 이때 ===을 사용하면 undefined출력(이유는 numArr가 위에서 문자열로 바꿔주었기 때문) if(numArr[i] == 8)&#123; // 여기서 8이 나올때마다 1씩 증가시켜주는 연산식을 사용한다. 밑의 경우 count+1을 count에 저장한다는 뜻의 연산자인 +=을 사용하였다. count += 1; &#125; &#125; &#125; return count;&#125;console.log(searchEight(10000)); // 4000console.log(searchEight(10088)); // 4018console.log(searchEight(50000)); // 20000 문제를 풀며 배운점 count문을 이해해야 하는 풀 수 있는 문제로 값을 초기화 시키고 저장하는 방법을 알아야한다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"원하는 숫자 찾기","slug":"알고리즘-Algorithm/원하는-숫자-찾기","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/원하는-숫자-찾기/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"짝수와 홀수(JAVASCRIPT)","slug":"js(EvenOrOdd)","date":"2017-08-16T09:54:10.000Z","updated":"2017-09-17T10:19:20.000Z","comments":true,"path":"2017/08/16/js(EvenOrOdd)/","link":"","permalink":"http://yoursite.com/2017/08/16/js(EvenOrOdd)/","excerpt":"","text":"짝수와 홀수문제evenOrOdd 함수는 정수 num을 매개변수로 받는다. num은 1이상의 정수이며, num이 음수인 경우는 없다. num이 짝수일 경우 ‘Even’을 반환하고 홀수인 경우 ‘Odd’를 반환하도록 evenOrOdd에 코드를 작성하라. 풀이(if문)12345678910111213// If문function EvenOrOdd(num) &#123; if (num % 2 == 0) &#123; // num을 짝수인지 조건을 써준다. return 'Even'; &#125; else &#123; // 그렇지않은 경우 홀수인지를 써준다. return 'Odd'; &#125;&#125; console.log(EvenOrOdd(0)); // evenconsole.log(EvenOrOdd(2)); // evenconsole.log(EvenOrOdd(3)); // oddconsole.log(EvenOrOdd(15)); // odd 풀이(3항연산자)12345678// 3항 연산자function EvenOrOdd(num) &#123; return (num % 2 == 0) ? \"Even\" : \"Odd\"; // num이 짝수인지 홀수인지 확인하는 조건을 써주고 삼항연산문을 사용하여 값을 정한후 값을 출력한다.&#125; console.log(EvenOrOdd(0)); // evenconsole.log(EvenOrOdd(2)); // evenconsole.log(EvenOrOdd(3)); // oddconsole.log(EvenOrOdd(15)); // odd 문제를 풀며 배운점 if문보다 3항연산자가 더 짧은 코드를 만들 수 있다다는 것을 배웠다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"짝수와 홀수","slug":"알고리즘-Algorithm/짝수와-홀수","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/짝수와-홀수/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"최단 거리 1차원 점의 쌍 구하기(JAVASCRIPT)","slug":"js(daum)","date":"2017-08-15T09:54:10.000Z","updated":"2017-09-17T10:14:23.000Z","comments":true,"path":"2017/08/15/js(daum)/","link":"","permalink":"http://yoursite.com/2017/08/15/js(daum)/","excerpt":"","text":"최단 거리 1차원 점의 쌍 구하기문제1차원의 점들이 주어졌을 때, 그 중 가장 거리가 짧은 것(들)의 쌍을 배열로 반환하는 함수를 작성하라. (단 점들의 배열은 모두 정렬되어있다고 가정한다.) 예를들어 [1, 3, 4, 8, 13, 17, 20, 23, 24]이 주어졌다면, 결과값은 [[3, 4], [23, 24]]가 될 것이다. 풀이1234567891011121314151617181920212223242526272829303132333435function findMinDistance(array)&#123; // return용 배열(최단거리) var shortests = []; // 두점간의 최단거리 var minDistance = Number.MAX_VALUE; // reduce를 사용하여 배열에서 자기자신과 바로 전 값을 비교하여 준다. array.reduce(function (pre, cur) &#123; // distance라는 변수를 선언해주어 현재값과 전값을 빼주어 그 차이를 저장을 해준다. var distance = Math.abs(pre - cur); // 두 점간의 거리가 지금까지 조사된 최단 거리(이때 위에서 저장한 distance의 값과 다시 재할당된 minDistance의 값을 비교해 준다.) if (distance === minDistance)&#123; // 최단 거리가 점점 짧아지는데 제일 짧은 distance와 갔다면 push메소드를 사용하여 조건을 만족하는 두 수를 배열의 형태로 만들어 뒤에 저장시켜준다. shortests.push([pre, cur]); &#125; // 두 점간의 거리가 최단 거리이면 if (distance &lt; minDistance)&#123; // distance값과 minDistance값을 비교하여 그것보다 작으면 mindistance에 세로 할당하여 넣어준다. minDistance = distance ; // shortests에 새로 배열의 형태로 값을 할당한다. shortests = [[pre, cur]]; &#125; return cur; &#125;); return shortests; &#125;// 1차원 점의 배열var array = [1, 3, 4, 8, 13, 17, 20, 23, 24];console.log(findMinDistance(array)); // [[3, 4], [23, 24]]var array= [-5, -4, 1, 2, 3, 20, 23, 24];console.log(findMinDistance(array)); // [ [ -5, -4 ], [ 1, 2 ], [ 2, 3 ], [ 23, 24 ] ] 문제를 풀며 느낀점 Number의 메소드들을 사용하는 법을 배웠다. 새로운 배열을 만들어 배열안에 배열을 넣는 법등을 이 문제를 통해 알게 되었다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"최단 거리 1차원 점의 쌍 구하기","slug":"알고리즘-Algorithm/최단-거리-1차원-점의-쌍-구하기","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/최단-거리-1차원-점의-쌍-구하기/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"CheckPalindrom(JAVASCRIPT)","slug":"js(checkPalindrom)","date":"2017-08-14T09:54:10.000Z","updated":"2017-09-17T10:10:49.000Z","comments":true,"path":"2017/08/14/js(checkPalindrom)/","link":"","permalink":"http://yoursite.com/2017/08/14/js(checkPalindrom)/","excerpt":"","text":"CheckPalindrom문제단어를 거꾸로해도 거꾸로 하지 않은 단어와 같은 단어인지 체크해주어서 맞으면 true를 반환하고 틀리면 false를 반환하여라. 풀이(1번)12345678910111213141516171819202122function checkPalindrom(str)&#123; // 단어를 체크해준다. var strReverse = str .split('').reverse().join(''); // strReverse를 선언해주어 역문자열을 저장한다. // .split('') -&gt; 단어를 하나씩 나누어 배열로 담아주어야 한다. // .split('').reverse() -&gt; 배열로 담아놓은 단어를 뒤집어 준다. // .split('').reverse().join('') -&gt; 뒤집어준 단어들을 다시 문자열로 변환시켜준다. if(str == strReverse) &#123; // 위에서 선언한 역문자열과 문자열을 같은지 체크해주는 조건문을 만든다. if (str.length == 1)&#123; //한글자 이상이어야 true를 반환하는 조건문을 생성한다. return(false); &#125; else &#123; return (true); &#125; &#125; else &#123; return (false); &#125;&#125;console.log(checkPalindrom('dad')); //trueconsole.log(checkPalindrom('mom')); //trueconsole.log(checkPalindrom('palindrom')); //falseconsole.log(checkPalindrom('s')); //true 풀이(2번)12345678function checkPalindrom(str)&#123; return str === str.split('').reverse().join('');&#125;console.log(checkPalindrom('dad')); //trueconsole.log(checkPalindrom('mom')); //trueconsole.log(checkPalindrom('palindrom')); //falseconsole.log(checkPalindrom('s')); //true 문제를 풀며 배운점 문자열의 메소드들을 사용하여 보았고 배열을 만들고 다시 문자열로 합쳐주는 메소드등을 사용할 수 있다는 점을 배웠다. 더 간결하게 코드를 만들 수 있다는 것을 배웠다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"CheckPalindrom","slug":"알고리즘-Algorithm/CheckPalindrom","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/CheckPalindrom/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"NumPY(JAVASCRIPT)","slug":"js(string)","date":"2017-08-09T09:54:10.000Z","updated":"2017-09-17T10:05:42.000Z","comments":true,"path":"2017/08/09/js(string)/","link":"","permalink":"http://yoursite.com/2017/08/09/js(string)/","excerpt":"","text":"NumPY문제numPY함수는 대문자와 소문자가 섞여있는 문자열 s를 매개변수로 입력받는다. 대소문자를 구별하지 않으며 s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 true, 다르면 false를 리턴하도록 함수를 완성하라. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 true를 리턴한다. 예를들어 s가 ‘pPoooyY’면 true를 리턴하고 ‘Pyy’라면 false를 리턴한다. 풀이(for문)1234567891011121314151617181920//for문function numPY(s) &#123; var cntP = 0; var cntY = 0; s = s ? s : '' ; var lowerCaseStr = s.toLowerCase(); for(var i=0; i &lt; lowerCaseStr.length; i++)&#123; // 자바스크립트는 컴파일 시점에 에러 검출이 안된다. 실행이 될때 에러가 검출이 된다. if(lowerCaseStr[i] === 'p') cntP++; if(lowerCaseStr[i] === 'y') cntY++; &#125; return (cntP === cntY);&#125;console.log(numPY('pPoooyY')); // trueconsole.log(numPY('Pyy')); // falseconsole.log(numPY('ab')); // trueconsole.log(numPY('')); // trueconsole.log(numPY()); // true 풀이(정규표현식)123456789101112// 정규표현식function numPY(s) &#123; s = s ? s : ''; // return (s.match(/p/gi).length === s.match(/y/gi).length); return (s.match(/p/gi) ? s.match(/p/gi).length : 0) === (s.match(/y/gi) ? s.match(/y/gi).length : 0); &#125;console.log(numPY('pPoooyY')); // trueconsole.log(numPY('Pyy')); // falseconsole.log(numPY('ab')); // trueconsole.log(numPY('')); // trueconsole.log(numPY()); // true 문제를 풀며 배운점 for문을 사용하는 법을 알았다. 정규표현식을 사용하여 만들어 보았다. 3항연산문을 사용하여 보았다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"NumPY","slug":"알고리즘-Algorithm/NumPY","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/NumPY/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"날짜의 요일 찾기(JAVASCRIPT)","slug":"ja(day)","date":"2017-08-09T09:54:10.000Z","updated":"2017-09-17T10:05:18.000Z","comments":true,"path":"2017/08/09/ja(day)/","link":"","permalink":"http://yoursite.com/2017/08/09/ja(day)/","excerpt":"","text":"날짜의 요일 찾기아무 연도와 날짜를 입력하면 그 날의 요일을 찾아주는 알고리즘 문제이다. 1234567891011function getDayName(a,b)&#123; var today = new Date(2016, a-1, b); var dayNames = ['(SUN)', '(MON)', '(TUE)', '(WED)', '(THU)', '(FRI)', '(SAT)']; var day = dayNames[today.getDay()]; return day;&#125;console.log(getDayName(2,7)); // (SUN)console.log(getDayName(5,24)); // (TUE)console.log(getDayName(7,30)); // (SAT)console.log(getDayName(10,04)); // (TUE) 알고리즘 문제를 풀며 배운점 Date메소드를 사용하여 날짜를 찾는 것 getDay()메소드 사용법","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"요일 찾기","slug":"알고리즘-Algorithm/요일-찾기","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/요일-찾기/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]}]}