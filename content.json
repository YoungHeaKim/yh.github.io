{"meta":{"title":"YoungHeaKim's Blog","subtitle":"JavaScript / Node.js / HTML / CSS","description":null,"author":null,"url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Docker","slug":"Docker","date":"2017-09-28T09:54:10.000Z","updated":"2017-09-29T12:44:05.000Z","comments":true,"path":"2017/09/28/Docker/","link":"","permalink":"http://yoursite.com/2017/09/28/Docker/","excerpt":"","text":"Dockerdocker를 깐 후 터미널에 밑의 명령어를 치면 실행이 된다.1docker run -it ubuntu bash mac에서 리눅스를 실행 시킬 수 있다.docker box를 실행을 하면 위의 명령어의 경우 docker를 실행했을 때 리눅스를 켠 후 ubuntu를 적은 용량으로 가상 머신을 열어 실행을 할 수 있다.용량이 적어서 사용하기 빠르다. 리눅스 컨테이너운영체제의 가장 밑부분을 커널이라고 하는데 이 커널이 윈도우와 맥이 달라서 각자 실행할 수 있는 프로그램이 다르다.커널위에 운영체제 편의기능이 있고 그위에 응용프로그램이 있다.커널에는 하드웨어와 디스플레이, 네트워크, 키보드, 마우스 등과 프로세스 스케줄링과 같은 것들이 담당한다.운영체제 편의기능에는 Unix와 Linux등이 있다.맥은 Unix다라고 말하는 이유는 커널을 Unix로 만들었기 때문이다. 그런대 커널은 무겁고 사용하기 힘든 프로그램이다. 커널위에서 운영체제를 여러개 실행하는 것처럼 보이게 하는것을 리눅스 컨테이너라고 한다. 프로세스 / 네트워크 격리 (한 커널위에서 운영체제가 충돌하지 않게 만드는 일) 파일 시스템 격리 (docker를 사용하여 ubuntu를 실행할 경우 용량이 작아 몇100개를 동시에 실행할 수 있다.) 리눅스 컨테이너이기 때문에 맥에서는 리눅스가 하나 돌아가고있고 리눅스 커널 위에 리눅스 컨테이너가 돌아가고 있다. docker의 mongo1docker run --name some-mongo -P -d mongo 위의 코드를 실행을 시켜 docker의 mongo를 깔아준다.그 후에 밑의 코드를 실행을 시켜주면 결과창이 뜬다.1docker ps 위의 사진에서 ports를 확인해주면 된다.그렇지만 ports를 우리의 서버에도 맞게 바꿔주어야하는데 이때는 docker를 지워야한다.1docker rm -f 1docker run --name some-mongo -p 27017:27017 -d mongo docker의 ports를 지정해준다.그 후에 docker mongo를 설치를 한 후 열어준다.설치를 한 후 위의 사진처럼 창을 만드려면 command+t를 누른 후 새 창을 만든 후 명령어를 치고 한줄씩 실행할 경우에는 F5를 누르면 된다. 전체를 실행할 경우 2번을 도는 command+enter를 누르면 된다. docker의 mysql위의 코드처럼 실행을 해주고 mysql에서 새로 만들기를 한 후 port부분만 위에서 지정해준 port로 입력을 해주면 사용이 가능하다. 윈도우와 리눅스의 운영서버와 개발머신이 달라 충돌이 나는데 이때 docker를 사용해서 윈도우에서는 리눅스 컨테이너 개발을 만들어주고 리눅스에서는 리눅스 컨테이너를 운영을 해주어 어디서든 리눅스를 편하게 사용할 수 있게 만들어준다. 밑의 사진처럼 명령어를 치면 docker 컨테이너 안에 열려있는 파일등을 볼수 있다.그리고 다시 들어갈 수도 있는데 이때는 밑의 사진의 명령어를 치면 밑에와 같이 확인이 가능하다.그리고 commit도 할수 있는데 이미지로 저장이 되어있고 사진도 다시 시작이 가능하다.git과 비슷하지만 docker는 가상서버에있는 모든 변경사항을 저장할 수 있다. docker 실제 사용docker를 설치해놓으면 mysql과 mongoDB를 설치하지않아도 docker만 깔려있다면 따로 깔려있지 않는 컴퓨터에서도 mysql과 mongoDB를 사용할 수 있다.1docker-compose up 위의 코드를 사용하면 docker파일이 실행되며 모든파일을 install해준다. 그 후에 listening이 뜨면 localhost:3000으로 접속하면 접속이 된다는 것을 알 수 있다.컨테이너끼리 링크를 맺을 수 있다.만약 db, redis, web이 있을 때 web에는 db와 redis에 링크를 걸어야할 때 실제 사용 코드에서는 밑에와 같이 사용한다.이때 chat의 겨우 맨마지막에 공유기를 만들어 주어야 위와 같이 사용을 할 수 있다. 켜져있는 docker를 지우는 방법1docker rm -f (각 docker의 번호 앞 3자리) docker의 image를 지우는 방법1docker rmi -f (각 docker의 번호 앞 3자리) 로깅 / 모니터링 / 에러리프팅로깅최대한 자세하게 로깅을 남겨야 어디서 오류가 났을 경우 로깅을 보고 찾아야한다. 모니터링메모리 사용량과 같은 것을 큰 모니터에 그래프를 띄워놓은 것을 확인해야 한다.keymetrics를 사용하여 모니터링을 쉽게할 수 있다. 링크Ports 80 (tcp out) and 43554 (tcp in/out)를 열어야 더 많은 것을 사용 가능하다. 또 다른 모니터링 기능을 하는 것은 cloud watch가 있다.사용법은 대쉬보드 접속 후 대쉬보드를 만들어 주고 그안에 위젯을 추가 후 원하는 것을 선택하여 사용하면 그래프를 볼 수 있다. 에러리프팅대표적인 에러리프팅 도구로는 Sentry와 bugsnag가 있다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Docker","slug":"Node-js/Docker","permalink":"http://yoursite.com/categories/Node-js/Docker/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"Fork 뜬 후 Branch 만들기","slug":"git(fork)","date":"2017-09-23T09:54:10.000Z","updated":"2017-09-23T13:12:13.000Z","comments":true,"path":"2017/09/23/git(fork)/","link":"","permalink":"http://yoursite.com/2017/09/23/git(fork)/","excerpt":"","text":"fork 뜨는 법사진의 오른쪽 상단에 fork버튼을 누른다. 내 컴퓨터와 연결하는 법 clone을 누른후 밑의 주소를 복사 후 터미널에서 명령어를 친다. 1git clone (자신의 github에서 clone 주소) 터미널에서 클론이 된 폴더로 들어간다. 1cd (폴더명) 터미널에서 연결이 되었는지 확인을 한다. 1git remote -v 이 때의 결과창은 밑의 코드와 같이 나온다.12origin https://github.com/YoungHeaKim/til.git (fetch)origin https://github.com/YoungHeaKim/till.git (push) fork를 뜬 사람의 주소로 들어간 후 clone주소를 복사한다. 1git remote add (fork 뜬 사람의 별명) (fork 뜬 사람의 주소) 연결이 잘 되어 있는 지 확인을 한다. 1git remote -v 결과는1234origin https://github.com/YoungHeaKim/to-do-list.git (fetch)origin https://github.com/YoungHeaKim/to-do-list.git (push)upstream https://github.com/seultt/to-do-list.git (fetch)upstream https://github.com/seultt/to-do-list.git (push) 파일을 올릴 때는 2가지 방법이 있다. 첫번째 방법 add, commit을 한 후 자신의 github에 올린 후 pull-request를 보낸다.1git push origin (branch 이름) 두번째 방법 add, commit을 한 후 포크를 떠 온 사람의 github로 바로 pull-request를 보낸다. 1git push -set--(포크해온 사람의 별칭) (branch 이름) pull을 할 경우1git pull (fork 뜬 사람의 별명) (branch 이름) 다른 사람이 자신의 repository를 fork해간 경우 clone을 한 후 1git clone (자신의 repository 주소) 터미널에서 해당 폴더로 이동 한다. 1cd (폴더 이름) fork를 떠간 사람과 연결해야 하기 위해 1git remote add (fork해간 사람의 repo주소) push를 방법 1git push origin (branch 이름) pull을 할 경우 1git pull origin (branch 이름)","categories":[{"name":"GIT","slug":"GIT","permalink":"http://yoursite.com/categories/GIT/"},{"name":"FORK","slug":"GIT/FORK","permalink":"http://yoursite.com/categories/GIT/FORK/"}],"tags":[{"name":"GIT","slug":"GIT","permalink":"http://yoursite.com/tags/GIT/"},{"name":"FORK","slug":"FORK","permalink":"http://yoursite.com/tags/FORK/"},{"name":"BRANCH","slug":"BRANCH","permalink":"http://yoursite.com/tags/BRANCH/"}]},{"title":"OAuth","slug":"oauth","date":"2017-09-19T09:54:10.000Z","updated":"2017-09-23T13:12:19.000Z","comments":true,"path":"2017/09/19/oauth/","link":"","permalink":"http://yoursite.com/2017/09/19/oauth/","excerpt":"","text":"WPSN OAuth최근에 웹을 사용한 경험이 있는 분들은 대부분 “페이스북으로 로그인” 버튼을 한 번 쯤 사용해보셨을 겁니다. 이 때 사용되는 인증 절차가 바로 OAuth입니다.제각각이던 인증 방식을 표준화한 것을 OAuth라고 한다.OAuth를 사용하면 사용자의 아이디와 암호가 노출되지 않도록 하면서도 애플리케이션에 API 접근 권한을 안전하게 위임할 수 있다. OAuth 역할만약 trello에서 google의 로그인을 사용할 때 자원 소유자OAuth를 통해 보호되고 있는 자원을 소유하고 있는 자원의 실제 소유자입니다.웹 애플리케이션의 사용자입니다. 자원 서버사용자 소유의 자원을 제공하는 서버. API 서버라고 봐도 무방합니다. 인증 서버소규모 서비스의 경우 자원 서버와 같은 서버에 위치해있는 경우가 많습니다.인증 서버는 google이 된다. 클라이언트OAuth를 통해 보호되고 있는 자원에 사용자 대신 접근하려고 하는 주체를 말합니다. 보통 자원 서버가 제공하는 API를 사용하려고 하는 웹 애플리케이션 서버를 가리킵니다.클라이언트는 트렐로가 된다. 사용자(자원 소유자)는 웹 애플리케이션(OAuth 클라이언트)에 인증 시작을 위한 요청을 보낸다. 웹 애플리케이션은 인증 서버로 사용자의 웹 브라우저를 리다이렉트 시킨다. (OAuth 클라이언트 정보가 포함됨) 사용자는 인증 서버에서 보여주는 화면을 통해 웹 애플리케이션이 요구하는 권한을 확인하고, 웹 애플리케이션이 본인 대신에 인증 정보를 활용할 수 있도록 허가한다. 인증 서버는 사용자의 웹 브라우저를 다시 웹 애플리케이션으로 리다이렉트 시킨다 (인증 코드 포함, 인증코드를 사용하여 access Token을 준다.) 웹 애플리케이션은 인증 코드를 포함시킨 요청을 인증 서버에 보내고, 액세스 토큰을 응답받는다. 웹 애플리케이션은 이제부터 액세스 토큰을 이용해 자원 서버를 사용할 수 있게 된다. 보통 가장 처음으로 사용자에 대한 정보를 가져온다. 해당 사용자 정보를 이용해 성공적으로 인증이 되었다는 사실을 사용자에게 보여준다. 사용자는 웹 애플리케이션을 통해서 자원 서버에 저장되어 있는 정보를 활용할 수 있게 된다. 우리가 만들 사이트도 사용자 클라이언트 인증서버가 신뢰를 확보하기위해 위의 절차를 거쳐야 한다. OAuth의 scope어떤 정보를 사용자에게 허락을 받을 때 Scope를 사용해준다.google은 큰 회사이기 때문에 원하는 Scope를 하나씩 설정을 해주어야 사용할 수 있다. id암호화새로운 table을 만들고 provider와 provider_user_id를 local로 만들고 그 후에 두개의 테이블을 provider_user_id는 새로만든 table에 id와 연결 시켜주면 된다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"로그인 연동","slug":"Node-js/로그인-연동","permalink":"http://yoursite.com/categories/Node-js/로그인-연동/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"OAuth","slug":"OAuth","permalink":"http://yoursite.com/tags/OAuth/"}]},{"title":"Passport","slug":"passport","date":"2017-09-19T09:54:10.000Z","updated":"2017-09-23T13:12:24.000Z","comments":true,"path":"2017/09/19/passport/","link":"","permalink":"http://yoursite.com/2017/09/19/passport/","excerpt":"","text":"WPSN PassportPassport는 다양한 인증 수단을 지원할 수 있도록 추상화된 인증 미들웨어입니다. StrategyPassport는 인증 절차를 정의하기 위해 strategy라는 개념을 사용특정 인증 방식에 대해 정해진 방식대로 strategy를 구현하기만 하면, express와 같은 웹 서버와 쉽게 연동할 수 있다.1234567891011121314151617// passport가 \"사용자 이름과 암호 기반 인증\"을 수행하도록 strategy 등록passport.use(new LocalStrategy((username, password, done) =&gt; &#123; query.compareUser(username, password) .then(user =&gt; &#123; // 인증 성공 done(null, user) &#125;) .catch(err =&gt; &#123; if (err instanceof query.LoginError) &#123; // 인증 실패: 사용자 책임 done(null, false, &#123;message: err.message&#125;) &#125; else &#123; // 인증 실패: 서버 책임 done(err) &#125; &#125;)&#125;)) passport에서 인증이 성공할 때는 done(null,user)를 사용하면 passport로 넘어가 다음으로 진행을 해준다.compareUser는 우리가 직접 만들어 주어야 한다. passport.authenticate()strategy를 이용해 passport가 인증을 위한 라우트 핸들러를 생성하게 할 수 있다.123456// passport-local을 통해 생성한 라우트 핸들러app.post('/login', passport.authenticate(('local'), &#123; successRedirect: '/', // 인증 성공 시 리다이렉트시킬 경로 failureRedirect: '/login', // 인증 실패 시 리다이렉트시킬 경로 failureFlash: '아이디 혹은 패스워드가 잘못되었습니다.' // 인증 실패 시 표시할 메시지&#125;)) flash를 사용하여 메세지도 보여줄 수 있다.strategy마다 한번씩 써주어야 한다. serializeUser, deserializeUser프로그램 상의 어떤 객체를 바이너리 혹은 텍스트의 형태로 변환하는 작업을 직렬화(serialization), 그 반대를 역직렬화(deserialization)라고 합니다.직렬화 - 객체를 문자열로 바꿔주는 작업역직렬화 - 문자열을 객체로 바꿔주는 작업위의 passport와 다르게 이 두개는 한번만 사용해주면 된다.12345678910111213141516// passport가 유저 정보를 세션에 저장할 수 있도록 직렬화passport.serializeUser((user, done) =&gt; &#123; done(null, user.id)&#125;)// passport가 세션으로부터 유저 객체를 가져올 수 있도록 역직렬화passport.deserializeUser((id, done) =&gt; &#123; query.getUserById(id) .then(user =&gt; &#123; if (user) &#123; done(null, user) // req.user에 저장됨 &#125; else &#123; done(new Error('해당 아이디를 가진 사용자가 없습니다.')) &#125; &#125;)&#125;) 장점은 나중에 strategy를 추가할때 좋다. req.login, req.logout위의 authenticate()에서 로그인을 되게 해주지만 req.login메소드는 회원 가입 이후에 자동으로 로그인을 시켜주려는 목적으로 사용되고 req.logout메소드는 현재 세션에 들어있는 인증 정보를 지우고 로그아웃을 시키는 메소드이다.12345678910111213141516171819202122// loginapp.post('/register', (req, res, next) =&gt; &#123; query.createUser(req.body.username, req.body.password) .then(user =&gt; &#123; // 회원 가입 시 자동으로 로그인 시키고 리다이렉트 req.login(user, err =&gt; &#123; if (err) &#123; next(err) &#125; else &#123; res.redirect('/') &#125; &#125;) &#125;) .catch(util.flashError(req, res))&#125;)// logoutapp.post('/logout', (req, res) =&gt; &#123; // passport가 제공하는 `req.logout` 메소드 req.logout() res.redirect('/login')&#125;) passport.initialize()Express 앱에서 Passport를 사용하기 위해서는 다음과 같이 미들웨어를 주입해주어야 합니다.인증 과정에서 세션을 사용하지 않는다면 passport.session()은 주입하지 않아도 무방합니다.맨위에 써주는 것이다.123// passport 관련 미들웨어 삽입app.use(passport.initialize())app.use(passport.session()) JWT를 사용해주는 경우에는 안써주어도 된다. 쿠키 이름 저장쿠키이름을 저장할 떄 프로젝트마다 다른 이름을 써주어야 나중에 구별하기 쉽다.1234app.use(cookieSession(&#123; name: 'session', keys: ['mysecret']&#125;))","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"로그인 연동","slug":"Node-js/로그인-연동","permalink":"http://yoursite.com/categories/Node-js/로그인-연동/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"passport","slug":"passport","permalink":"http://yoursite.com/tags/passport/"}]},{"title":"REST API","slug":"restApi","date":"2017-09-18T09:54:10.000Z","updated":"2017-10-05T09:39:52.000Z","comments":true,"path":"2017/09/18/restApi/","link":"","permalink":"http://yoursite.com/2017/09/18/restApi/","excerpt":"","text":"WPSN REST APIREST(Representaitonal State Transfer)한 사람이 논문으로 만들어 발표한 것이다. 설계원칙 클라이언트-서버 아키텍처 무상태(statelessness): 클라이언트의 세션 상태는 웹 서버 대신 클라이언트에 저장되어야 합니다. 캐시 가능: 웹 서버의 응답은, 캐시 가능 여부에 대한 정보를 포함해야 합니다. 계층 시스템: 클라이언트는 요청이 정확히 어느 웹 서버에 도달할 지, 중간 매체가 있는지 없는지를 모르더라도 별다른 문제없이 서비스를 사용할 수 있어야 합니다. 일관된 인터페이스 자원은 URI를 통해서 식별하고, 자원의 제공 형태를 식별자에 포함시키지 않습니다. 서버가 요청을 잘 처리할 수 있도록 각 요청은 충분한 정보를 포함하고 있어야 합니다. (Content-Type 등) 필요 시 코드 전송(Code on demand): 웹 서버는 자바 애플릿, 플래시, 자바스크립트 등의 제공을 통해 클라이언트의 기능을 확장시킬 수 있습니다. 위 설계 원칙을 따름으로써 웹 서버의 좋은 속성 높은 성능을 달성하기 위해서는 무상태와 캐시 가능을 사용해야 한다. 확장가능성(Scalability) 인터페이스의 단순함 웹 서버의 실시간 업데이트가 가능해지는 방법은 여러 서버에 요청을 보내고 그것이 처리될 때까지 서버를 유지를 시키고 만약 업데이트를 할 것이 있으면 다른 서버에게 요청을 하고 요청이 끝나면 서버를 내리는 형태로 만든 것이다. REST APIREST 원칙을 따르는 웹 API를 가지고 REST API라고 부릅니다. RESTful URI 설계REST API의 URI는 기본적으로 ‘자원’을 뜻한다.URI를 통해 자원을 표현할 때는 밑의 기본 원칙을 따른다. 슬래시(/) 문자는 자원 간 계층관계를 나타내는 데 사용합니다. 마지막 문자로 슬래시를 포함하지 않습니다. 띄어쓰기를 표현할 때는 하이픈(-)을 사용하고, 밑줄(_)을 사용하지 않는다 대문자 대신 소문자만을 사용합니다. 경로에 확장자를 쓰지 않습니다. 내용 협상을 위해서는 Accept 헤더를 사용합니다. Document보통 하나의 객체 혹은 데이터베이스 레코드를 나타내는 단일 자원이다.123https://api.example.com/userhttps://api.example.com/service-infohttps://api.example.com/resource 컬렉션 뒤에 자원의 식별자를 붙여서 도큐먼트를 나타낼 수도 있습니다.12https://api.example.com/todos/123https://api.example.com/articles/how-to-design-rest-api Controller자원에 대한 단순한 CRUD(Create, Read, Update, Delete)는 HTTP 메소드를 통해서 할 수 있지만, 단순 CRUD가 아닌 경우에는 자원 뒤에 동사를 붙여서 해당 동작을 표현할 수 있습니다.patch요청을 보내 controller를 사용하지 않을 수 있지만 patch요청은 update를 할 때는 데이터가 원하는 데이터와 다를 수 있기 때문에 지양하는 것이 좋다.1https://api.example.com/todos/123/finish REST API 통신 설계의미에 맞는 HTTP 메소드와 상태 코드를 사용해야 한다.컬렉션, 도큐먼트, 컨트롤러에 대해서 HTTP메소드를 아래와 같이 사용한다. 컬렉션123456789# 컬렉션에 속해있는 자원을 모두 가져오기 위해 컬렉션 URI에 GET 요청을 보냅니다.GET https://api.example.com/todos# 컬렉션에 대한 filtering이나 pagination을 위해 쿼리 스트링을 사용할 수 있습니다.GET https://api.example.com/todos?complete=true&amp;assignee=meGET https://api.example.com/todos?page=2# 컬렉션 내에 새로운 자원을 생성하기 위해 POST 요청을 보냅니다.POST https://api.example.com/todos 도큐먼트12345678910# 단일 도큐먼트를 읽어오기 위해 도큐먼트 URI에 GET 요청을 보냅니다.GET https://api.example.com/userGET https://api.example.com/todos/123# 도큐먼트를 수정하기 위해 PUT(치환) 혹은 PATCH(변경) 요청을 보냅니다.PUT https://api.example.com/todos/123PATCH https://api.example.com/user# 도큐먼트를 삭제하기 위해 DELETE 요청을 보냅니다.DELETE https://api.example.com/todos/123 이렇게 사용하면 안된다~~!!12345678# 자원의 생성을 위한 URI가 따로 존재하고 GET 메소드를 사용하는 경우GET /add_todo?title=mytodo# 자원 식별자를 쿼리 스트링에 포함시키는 경우GET /todo?id=1# 자원의 삭제를 위해 POST 메소드를 사용하는 경우POST /todos/1/delete?id=1 URL을 입력할 때 자동완성기능을 만들면서 미리 get요청을 보낸다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"REST API","slug":"Node-js/REST-API","permalink":"http://yoursite.com/categories/Node-js/REST-API/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"REST API","slug":"REST-API","permalink":"http://yoursite.com/tags/REST-API/"}]},{"title":"실시간 대화창(Soket.io)","slug":"soket","date":"2017-09-18T09:54:10.000Z","updated":"2017-09-23T13:12:02.000Z","comments":true,"path":"2017/09/18/soket/","link":"","permalink":"http://yoursite.com/2017/09/18/soket/","excerpt":"","text":"WebSocket클라이언트가 websocket 요청을 보내고 서버가 websocket을 지원하면 websocket의 응답을 보낸다. 이때 응답과 요청은 HTTP인대 연결이 되면 HTTP가 아닌 WebSocket이 되어 요청과 응답을 보낸다.요청을 보낼 때 CONNECTION: Upgrade를 보내고 응답을 Upgrade:websocket라고 답을 한것을 볼수 있다.밑의 content는 많이 사용한다.1DOMContentLoaded emit은 발산시키다라는 의미로 message라는 이벤트를 발산시키고 뒤의 데이터를 포함시켜서 보내는 것이다. HTTP는 내장 모듈로 HTTP의 서버를 만들어 주거나 express와 soket.io를 함께 사용하려면 써주어야 한다.밑에 방식으로 사용을 하여 io를 사용해준다.123const app = express()const server = http.Server(app)const io = socketio(server) 사전 정의된 이벤트 목록 ‘connect’ 혹은 ‘connection’: 클라이언트가 새 연결을 맺었을 때 ‘disconnect’: 클라이언트의 연결이 끊어졌을 때 ‘error’: 에러가 발생했을 때 ‘disconnecting’: 클라이언트가 연결을 끊기 직전에 1const socket = io() 위의 코드를 사용하면 모든 socket은 루트디렉토리로 간다.nameSpace로 가면 디렉토리를 가둬서 사용할 수 있다. socket객체는 서버에서 미리 저장되어 있는 것이다.html에 data-이라는 값을 불러올땐 dataset이라는 것으로 불러올수 있다.command + shift + n 누르면 secret 창이 뜬다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Soket.io","slug":"Node-js/Soket-io","permalink":"http://yoursite.com/categories/Node-js/Soket-io/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Soket.io","slug":"Soket-io","permalink":"http://yoursite.com/tags/Soket-io/"}]},{"title":"CSRF공격 방어","slug":"csrf","date":"2017-09-18T09:54:10.000Z","updated":"2017-09-23T13:12:08.000Z","comments":true,"path":"2017/09/18/csrf/","link":"","permalink":"http://yoursite.com/2017/09/18/csrf/","excerpt":"","text":"CSRFCross-site Request Forgery: 사이트 간 요청 위조 다른 공격 기법 XSS SQL Injection CSRF 공격 기법어떠한 요청을 img를 찾기위해 GET으로 보내기 때문에 그때 데이터를 조작할 수 있게 만든다.사이트가 다른 곳에서 요청을 보내면 다른 사이트에서 그것의 요청을 잘 받아들이는 것을 볼 수 있다.우리는 쿠키세션을 사용하고 있는데 쿠키는 한번 세팅을 하면 같은 주소에 요청을 보낼 때마다 시키지 않아도 자동으로 쿠키를 포함하여 요청을 보낸다. 해결방안우리 웹사이트에서 정말 보낸 요청이 맞는지를 확인을 해야한다.쿠키 말고도 다른 post 요청을 보내서 확인해야한다.우리 웹사이트에서만 보낼 수 있는 정보(CSRF 토큰)를 post요청을 하면 CSRF의 공격을 방어할 수 있다.단 유저마다 다른 CSRF 토큰을 사용하여야 한다. CSURFCSURF미들웨어를 사용하여 CSRF공격을 방어할 수 있다.사용자가 악의적인 웹 페이지에 접속했을 때 해당 웹 페이지에서 다른 서버로 요청을 보내어 정보를 조작하는 공격 기법입니다.CSRF는 SECRET과 TOCKEN을 만들어 두개의 서로 매칭이 되는지에 대헤 확인을 할수 있다.SECRET - Session에 저장한다.TOKEN - POST Body에 저장을 한다.Secret은 미들웨어를 사용하면 자동으로 Secret과 matching부분을 해주기 때문에 상관없다.그렇지만 POST body부분은 우리가 form작성 시 직접 포함시켜주어야 한다. 사용법1npm install --save csurf 그리고12345const csrfMiddleware = csurf()// 모든 라우터에 적용가능app.use(csrfMiddleware)// 모든 render에 추가&#123;rows, csrfToken: req.csrfToken()&#125; 모든 html에 form태그 안에 작성1&lt;input type=\"hidden\" name=\"_csrf\" value=\"&lt;%= csrfToken %&gt;\"&gt; knex seed file밑의 코드를 써주면 seed폴더안에 파일을 생성해준다.1knex seed:make (seed_name) 위에서 생성해준 파일에 밑의 js파일을 작성해 준다.12345678910111213141516171819202122232425262728const faker = require('faker')const randomstring = require('randomstring')exports.seed = function(knex, Promise) &#123; // Deletes ALL existing entries return knex('user') .insert(&#123; id: 'fast', password: 'campus' &#125;) .then(() =&gt; &#123; const arr = [] for (var i = 0; i &lt; 20; i++) &#123; arr.push( knex('url_entry') .insert(&#123; id: randomstring.generate(8), long_url: faker.internet.url(), user_id: 'fast' &#125;).then(console.log) ) &#125; return Promise.all(arr) &#125;) // promise가 감싸고 있는 값이 밑의 then에 들어간다. // .then(value =&gt; &#123;&#125;)&#125;;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"CSRF 공격 방어","slug":"Node-js/CSRF-공격-방어","permalink":"http://yoursite.com/categories/Node-js/CSRF-공격-방어/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"CSRF","slug":"CSRF","permalink":"http://yoursite.com/tags/CSRF/"}]},{"title":"원하는 숫자 찾기(JAVASCRIPT)","slug":"js(searchEight)","date":"2017-08-16T09:54:10.000Z","updated":"2017-09-17T10:24:39.000Z","comments":true,"path":"2017/08/16/js(searchEight)/","link":"","permalink":"http://yoursite.com/2017/08/16/js(searchEight)/","excerpt":"","text":"1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기문제1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라. 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. (※ 예를들어 8808은 3, 8888은 4로 카운팅 해야 함) 풀이1234567891011121314151617181920212223242526function searchEight(num) &#123; // 변수의 선언위치가 중요하다. 만약 for문안에 count를 선언해주면 for문이 실행 될 때마다 count=0;으로 초기화가 되기때문에 for문 밖에 써주는 것이 중요하다. var count = 0; // 1부터 10000까지 확인을 해야해서 반복문 사용 for (var numOrd = 1; numOrd &lt;= num; numOrd++)&#123; // num은 숫자형이기 때문에 문자열로 바꿔주고 str은 배열이 아님으로 split메소드를 사용하여 배열로 변화를 줘야함. var numArr = numOrd.toString().split(''); // i는 0부터 10000까지 도는 숫자에서 8을 검색하는 for문을 만듬 for (var i = 0; i &lt; numArr.length; i++)&#123; // numArr[i]를 사용하여 각 자리의 값을 8인지 비교 , 이때 ===을 사용하면 undefined출력(이유는 numArr가 위에서 문자열로 바꿔주었기 때문) if(numArr[i] == 8)&#123; // 여기서 8이 나올때마다 1씩 증가시켜주는 연산식을 사용한다. 밑의 경우 count+1을 count에 저장한다는 뜻의 연산자인 +=을 사용하였다. count += 1; &#125; &#125; &#125; return count;&#125;console.log(searchEight(10000)); // 4000console.log(searchEight(10088)); // 4018console.log(searchEight(50000)); // 20000 문제를 풀며 배운점 count문을 이해해야 하는 풀 수 있는 문제로 값을 초기화 시키고 저장하는 방법을 알아야한다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"원하는 숫자 찾기","slug":"알고리즘-Algorithm/원하는-숫자-찾기","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/원하는-숫자-찾기/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"짝수와 홀수(JAVASCRIPT)","slug":"js(EvenOrOdd)","date":"2017-08-16T09:54:10.000Z","updated":"2017-09-17T10:19:20.000Z","comments":true,"path":"2017/08/16/js(EvenOrOdd)/","link":"","permalink":"http://yoursite.com/2017/08/16/js(EvenOrOdd)/","excerpt":"","text":"짝수와 홀수문제evenOrOdd 함수는 정수 num을 매개변수로 받는다. num은 1이상의 정수이며, num이 음수인 경우는 없다. num이 짝수일 경우 ‘Even’을 반환하고 홀수인 경우 ‘Odd’를 반환하도록 evenOrOdd에 코드를 작성하라. 풀이(if문)12345678910111213// If문function EvenOrOdd(num) &#123; if (num % 2 == 0) &#123; // num을 짝수인지 조건을 써준다. return 'Even'; &#125; else &#123; // 그렇지않은 경우 홀수인지를 써준다. return 'Odd'; &#125;&#125; console.log(EvenOrOdd(0)); // evenconsole.log(EvenOrOdd(2)); // evenconsole.log(EvenOrOdd(3)); // oddconsole.log(EvenOrOdd(15)); // odd 풀이(3항연산자)12345678// 3항 연산자function EvenOrOdd(num) &#123; return (num % 2 == 0) ? \"Even\" : \"Odd\"; // num이 짝수인지 홀수인지 확인하는 조건을 써주고 삼항연산문을 사용하여 값을 정한후 값을 출력한다.&#125; console.log(EvenOrOdd(0)); // evenconsole.log(EvenOrOdd(2)); // evenconsole.log(EvenOrOdd(3)); // oddconsole.log(EvenOrOdd(15)); // odd 문제를 풀며 배운점 if문보다 3항연산자가 더 짧은 코드를 만들 수 있다다는 것을 배웠다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"짝수와 홀수","slug":"알고리즘-Algorithm/짝수와-홀수","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/짝수와-홀수/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"최단 거리 1차원 점의 쌍 구하기(JAVASCRIPT)","slug":"js(daum)","date":"2017-08-15T09:54:10.000Z","updated":"2017-09-17T10:14:23.000Z","comments":true,"path":"2017/08/15/js(daum)/","link":"","permalink":"http://yoursite.com/2017/08/15/js(daum)/","excerpt":"","text":"최단 거리 1차원 점의 쌍 구하기문제1차원의 점들이 주어졌을 때, 그 중 가장 거리가 짧은 것(들)의 쌍을 배열로 반환하는 함수를 작성하라. (단 점들의 배열은 모두 정렬되어있다고 가정한다.) 예를들어 [1, 3, 4, 8, 13, 17, 20, 23, 24]이 주어졌다면, 결과값은 [[3, 4], [23, 24]]가 될 것이다. 풀이1234567891011121314151617181920212223242526272829303132333435function findMinDistance(array)&#123; // return용 배열(최단거리) var shortests = []; // 두점간의 최단거리 var minDistance = Number.MAX_VALUE; // reduce를 사용하여 배열에서 자기자신과 바로 전 값을 비교하여 준다. array.reduce(function (pre, cur) &#123; // distance라는 변수를 선언해주어 현재값과 전값을 빼주어 그 차이를 저장을 해준다. var distance = Math.abs(pre - cur); // 두 점간의 거리가 지금까지 조사된 최단 거리(이때 위에서 저장한 distance의 값과 다시 재할당된 minDistance의 값을 비교해 준다.) if (distance === minDistance)&#123; // 최단 거리가 점점 짧아지는데 제일 짧은 distance와 갔다면 push메소드를 사용하여 조건을 만족하는 두 수를 배열의 형태로 만들어 뒤에 저장시켜준다. shortests.push([pre, cur]); &#125; // 두 점간의 거리가 최단 거리이면 if (distance &lt; minDistance)&#123; // distance값과 minDistance값을 비교하여 그것보다 작으면 mindistance에 세로 할당하여 넣어준다. minDistance = distance ; // shortests에 새로 배열의 형태로 값을 할당한다. shortests = [[pre, cur]]; &#125; return cur; &#125;); return shortests; &#125;// 1차원 점의 배열var array = [1, 3, 4, 8, 13, 17, 20, 23, 24];console.log(findMinDistance(array)); // [[3, 4], [23, 24]]var array= [-5, -4, 1, 2, 3, 20, 23, 24];console.log(findMinDistance(array)); // [ [ -5, -4 ], [ 1, 2 ], [ 2, 3 ], [ 23, 24 ] ] 문제를 풀며 느낀점 Number의 메소드들을 사용하는 법을 배웠다. 새로운 배열을 만들어 배열안에 배열을 넣는 법등을 이 문제를 통해 알게 되었다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"최단 거리 1차원 점의 쌍 구하기","slug":"알고리즘-Algorithm/최단-거리-1차원-점의-쌍-구하기","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/최단-거리-1차원-점의-쌍-구하기/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"CheckPalindrom(JAVASCRIPT)","slug":"js(checkPalindrom)","date":"2017-08-14T09:54:10.000Z","updated":"2017-09-17T10:10:49.000Z","comments":true,"path":"2017/08/14/js(checkPalindrom)/","link":"","permalink":"http://yoursite.com/2017/08/14/js(checkPalindrom)/","excerpt":"","text":"CheckPalindrom문제단어를 거꾸로해도 거꾸로 하지 않은 단어와 같은 단어인지 체크해주어서 맞으면 true를 반환하고 틀리면 false를 반환하여라. 풀이(1번)12345678910111213141516171819202122function checkPalindrom(str)&#123; // 단어를 체크해준다. var strReverse = str .split('').reverse().join(''); // strReverse를 선언해주어 역문자열을 저장한다. // .split('') -&gt; 단어를 하나씩 나누어 배열로 담아주어야 한다. // .split('').reverse() -&gt; 배열로 담아놓은 단어를 뒤집어 준다. // .split('').reverse().join('') -&gt; 뒤집어준 단어들을 다시 문자열로 변환시켜준다. if(str == strReverse) &#123; // 위에서 선언한 역문자열과 문자열을 같은지 체크해주는 조건문을 만든다. if (str.length == 1)&#123; //한글자 이상이어야 true를 반환하는 조건문을 생성한다. return(false); &#125; else &#123; return (true); &#125; &#125; else &#123; return (false); &#125;&#125;console.log(checkPalindrom('dad')); //trueconsole.log(checkPalindrom('mom')); //trueconsole.log(checkPalindrom('palindrom')); //falseconsole.log(checkPalindrom('s')); //true 풀이(2번)12345678function checkPalindrom(str)&#123; return str === str.split('').reverse().join('');&#125;console.log(checkPalindrom('dad')); //trueconsole.log(checkPalindrom('mom')); //trueconsole.log(checkPalindrom('palindrom')); //falseconsole.log(checkPalindrom('s')); //true 문제를 풀며 배운점 문자열의 메소드들을 사용하여 보았고 배열을 만들고 다시 문자열로 합쳐주는 메소드등을 사용할 수 있다는 점을 배웠다. 더 간결하게 코드를 만들 수 있다는 것을 배웠다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"CheckPalindrom","slug":"알고리즘-Algorithm/CheckPalindrom","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/CheckPalindrom/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"NumPY(JAVASCRIPT)","slug":"js(string)","date":"2017-08-09T09:54:10.000Z","updated":"2017-09-17T10:05:42.000Z","comments":true,"path":"2017/08/09/js(string)/","link":"","permalink":"http://yoursite.com/2017/08/09/js(string)/","excerpt":"","text":"NumPY문제numPY함수는 대문자와 소문자가 섞여있는 문자열 s를 매개변수로 입력받는다. 대소문자를 구별하지 않으며 s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 true, 다르면 false를 리턴하도록 함수를 완성하라. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 true를 리턴한다. 예를들어 s가 ‘pPoooyY’면 true를 리턴하고 ‘Pyy’라면 false를 리턴한다. 풀이(for문)1234567891011121314151617181920//for문function numPY(s) &#123; var cntP = 0; var cntY = 0; s = s ? s : '' ; var lowerCaseStr = s.toLowerCase(); for(var i=0; i &lt; lowerCaseStr.length; i++)&#123; // 자바스크립트는 컴파일 시점에 에러 검출이 안된다. 실행이 될때 에러가 검출이 된다. if(lowerCaseStr[i] === 'p') cntP++; if(lowerCaseStr[i] === 'y') cntY++; &#125; return (cntP === cntY);&#125;console.log(numPY('pPoooyY')); // trueconsole.log(numPY('Pyy')); // falseconsole.log(numPY('ab')); // trueconsole.log(numPY('')); // trueconsole.log(numPY()); // true 풀이(정규표현식)123456789101112// 정규표현식function numPY(s) &#123; s = s ? s : ''; // return (s.match(/p/gi).length === s.match(/y/gi).length); return (s.match(/p/gi) ? s.match(/p/gi).length : 0) === (s.match(/y/gi) ? s.match(/y/gi).length : 0); &#125;console.log(numPY('pPoooyY')); // trueconsole.log(numPY('Pyy')); // falseconsole.log(numPY('ab')); // trueconsole.log(numPY('')); // trueconsole.log(numPY()); // true 문제를 풀며 배운점 for문을 사용하는 법을 알았다. 정규표현식을 사용하여 만들어 보았다. 3항연산문을 사용하여 보았다.","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"NumPY","slug":"알고리즘-Algorithm/NumPY","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/NumPY/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"날짜의 요일 찾기(JAVASCRIPT)","slug":"ja(day)","date":"2017-08-09T09:54:10.000Z","updated":"2017-09-17T10:05:18.000Z","comments":true,"path":"2017/08/09/ja(day)/","link":"","permalink":"http://yoursite.com/2017/08/09/ja(day)/","excerpt":"","text":"날짜의 요일 찾기아무 연도와 날짜를 입력하면 그 날의 요일을 찾아주는 알고리즘 문제이다. 1234567891011function getDayName(a,b)&#123; var today = new Date(2016, a-1, b); var dayNames = ['(SUN)', '(MON)', '(TUE)', '(WED)', '(THU)', '(FRI)', '(SAT)']; var day = dayNames[today.getDay()]; return day;&#125;console.log(getDayName(2,7)); // (SUN)console.log(getDayName(5,24)); // (TUE)console.log(getDayName(7,30)); // (SAT)console.log(getDayName(10,04)); // (TUE) 알고리즘 문제를 풀며 배운점 Date메소드를 사용하여 날짜를 찾는 것 getDay()메소드 사용법","categories":[{"name":"알고리즘(Algorithm)","slug":"알고리즘-Algorithm","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/"},{"name":"요일 찾기","slug":"알고리즘-Algorithm/요일-찾기","permalink":"http://yoursite.com/categories/알고리즘-Algorithm/요일-찾기/"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","permalink":"http://yoursite.com/tags/JAVASCRIPT/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://yoursite.com/tags/알고리즘/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"HTML","slug":"htmlCss","date":"2017-07-16T09:54:10.000Z","updated":"2017-09-23T14:53:47.000Z","comments":true,"path":"2017/07/16/htmlCss/","link":"","permalink":"http://yoursite.com/2017/07/16/htmlCss/","excerpt":"","text":"구조언어 [(X)HTML &amp; XML] HTML (‘Hyper Text Makeup Language’) 컴퓨터 언어로서는 매우 느슨한 구조 다양한 플랫폼과 장치에 독립적인 정보교환 수당을 제공 XML (‘eXtensible Makeup Language’)⦁웹에서 구조화된 문서를 전송할 수 있도록 설계된 표준화된 텍스트 형식⦁HTML과는 달리 태그의 운용방법과 오류에 매우 엄격. XHTML (‘eXtensible Hyper Text Makeup Language’)⦁XHTML은 XML응용으로 써의 HTML4를 다시 공식화한 것 HTML5⦁HTML의 다음 버전으로 HTML4를 업그레이드 한 것 구조요소 – header, footer, aside, section 인라인 요소 – time, meter, progress 멀티미디어 관련 내장 요소에는 video와 audio가 있다. 표현언어 CSS (‘Cascading Style Sheer’) CSS에서는 폰트, 색상, 공백, 공간과 그 밖의 문서 표현 등을 자유롭게 지정 할 수 있는 기능. 동작 및 제어를 위한 DOM &amp; ECMA Script DOM (Document Object Model)은 웹 페이지의 구성 체계 구조설계 저작도구 설치 및 환경설정 웹 에디터 메모장, 에디트 플러스, 울트라 에디트, 압타나 등은 텍스트 기반의 웹 에디터 드림위버, 나모 웹 에디터 등은 위지윅 방식의 웹 에디터 웹(World Wide Web) 인터넷이 웹 웹의 동작 방식은 서버와 클라이언트 집을 지을 공간 - ‘서버(Server)’ 집의 주소 - ‘도메인(Domain)’ 요청 수단으로 사용하는 것 - ‘클라이언트(Client)’ 웹 프로그래밍의 이해 컴파일 방식(Compile) 사람과 컴퓨터가 이해할 수 있도록 중간에서 통역을 해주는 역할 비컴파일 방식(Script 포함) CGI (Common Gateway Interface) 웹 서버와 클라이언트 간에 필요한 정보를 교환할 수 있게 해 주는 일종의 인터 페이스 가장 먼저 개발된 언어 ASP (Active Server Page) CGI보다 서버부담을 덜 수 있다. PHP (Personal Home Page tools, Professional Hyper Text Preprocessor) 적은 명령어로 프로그래밍이 가능 Servlet/ JSP 서블릿 (Servlet; Server + Applet) JSP (Java Server pages) 시맨틱 웹 (Semantic Web) 인간만 이해 웹이 아닌 기계가 이해 기계처리가 가능한 웹 구현하려는 환경 : 인간의 언어 구조가 기계에도 이해될 수 있도록 하는 것 의미를 살린 마크업 제목은 제목의 의미를 가진 요소 목록 콘텐츠는 목록의 의미를 가진 요소로 마크업 요소에 id나 class를 이용하여 의미를 가지는 네이밍을 사용 ‘제목’의 의미를 가지는 h1요소를 사용하여 이 문서의 제목정보를 가질 수 있도록 한다. 학생 명단은 ‘목록’의 의미를 가진 u1요소를 사용 구조를 위한 XHTML마크업 언어 순차적 마크업 언어 동질의 환경에서 정보 저장 교환용으로 사용하기에 문제가 없지만, 서로 다른 시스템 간의 정보 교환용으로는 부적절 특정응용 소프트웨어에서만 인식될 수 있는 단점 대표적으로 HTML이다 서술적 마크업 언어 문서가 기본데이터와 구조(의미)만 가지기 때문에 결과적으로 문서구조와 표현정보를 분리할 수 있음 XHTML 순차적인 마크업의 기능과 서술적인 마크업의 장점을 수용한 마크업 언어 XHTML의 서식 요소 사용 시 종료 태그의 생략 불가능 요소명과 속 성명에 소문자 사용 빈 요소 사용 시 &lt;요소명/&gt; 형식으로 기술 ( 예: &lt;br/&gt; , &lt;img/&gt; ) 속성에 속성 값 생략 불가능 잘못된 중첩사용 불가능 모든 속성 값에 인용부로 사용 &lt;, &gt;, &amp;을 &lt;, &gt;, &amp; 로 변환하여 사용 (태그로 컴퓨터가 이해하기 때문) 주석은 바르게 사용하고 그 안에 –(더블데시) 사용 불가(/내용/ 통으로 주석) XHTML 구성요소 태그 (tag) &lt;tag&gt;~&lt;/tag&gt;가 기본형식 빈 요소일 경우 &lt;tag/&gt;를 사용 요소 (element) 시작&lt;tag&gt; 종료 &lt;/tag&gt;까지의 모든 명령어를 요소 속성 (attribute) 시작태그는 태그의 의미와 필요에 따라 개별적인 옵션을 가질 수 있는데, 이러한 옵션을 ‘속성’이라고 한다. 1&lt;img src=“주소”, alt=“굿타임 이벤트”&gt; 속성 리더기를 위해 작성 값 (Value) XHTML 문서의 기본 구조 DTD선언 (&lt;!doctype&gt; &lt;html&gt; ~ &lt;/html&gt; 모든 웹 페이지의 시작과 끝을 의미한다. &lt;head&gt; ~ &lt;/head&gt; &lt;body&gt; ~ &lt;/body&gt; 블록 요소와 인라인 요소 블록요소는 독립적 형태의 상자 제목(&lt;h1&gt; ~ &lt;h6&gt;), 문단(P요소), 작성자 요소 블럭요소 &gt; 인라인 요소 인라인 요소는 블록 상자 안의 일부 링크, 이미지, 강조 등이 해당&lt;link/&gt;예제로 css를 가장 많이 불러옴 문서형 정의 및 선언, 네임 스페이스, 휴먼 랭귀지 문서형 정의 및 선언(DTD; Document Type Definition) 엄격형(Strict) 호환형(Transitional) 프레임형(Frameset) 문서형 선언(DTD) 네임 스페이스 휴먼 랭귀지 XHTML 요소문서 정보와 문자 코드 세트(meta 요소) 문자 코드 세트 지정 키워드 지정 다양한 문서 정보 지정 문서 제목 정보를 제공 description 값으로 웹 페이지의 요약정보 제작자 정보 저작권 정보 및 검색 로봇 제어 여부등의 문서 정보를 지정 문서 제목 (title) 의미 없는 장식 문자 사용 → 요즘은 사용 안함 현재 페이지의 위치 경로를 나타내는 문서 제목 → 요즘 사용예: 네이버뉴스 :: 네이버 &gt; 뉴스 문단 관련 요소 제목( ~ ) 대제목, 중제목, 소제목 제목요소는 블록요소포함 할 수 없음 인라인요소, 텍스트 포함 가능 콘텐츠의 의미를 전달하는 헤딩 레이아웃 구조를 위한 헤딩사용 무의미한 헤딩은 CSS를 이용하여 지움 단락(p) 단락요소 안에는 a, img 등 인라인 요소와 텍스트만 포함 블록요소는 사용할 수 없다. ~ 을 사용하여 강조를 할 수 있다. br요소의 남용 줄바꿈(br) 강제 줄바꿈을 위한 line break 시 – 단락에서 행을 구분할 때 br사용 정렬하기 위해 강제로 br요소를 사용하여 문장 나누기 span요소와 padding 속성을 이용하여 글자 사이에 빈공간 추가 주소 (address) 연락처 정보를 address 요소 사용 인라인 요소, 텍스트 요소 포함 가능 블록요소 포함 불가능 형식: 작성자 정보 콘텐츠 일반주소 콘텐츠에 사용한 address 구분선 (hr) hr요소는 수평선으로 표현되어 구분선 역할을 하고, 빈 요소이다. 로 종료 태그 필요 없음 콘텐츠 영역과 사이드 영역을 구분하기 위해 사용한 hr요소 링크와 이미지 하이퍼 링크 &lt;a&gt; &lt;a href=“주소”&gt; &lt;img src=“주소”/&gt; ~ &lt;a/&gt; a요소는 텍스트나 이미지 콘텐츠에 링크를 걸 때 사용 href 요소, target 요소, title 요소 Transitional과 Frameset DTD 일 경우에만 target 속성을 지정 절대경로와 상대경로 절대경로 전체구조 내에서의 위치를 표시하는 방법 상대경로 ★★ 작업하고 있는 파일의 현재위치를 기준으로 지정하는 방법 여러 개의 같은 이름을 가지는 링크 a요소를 설정 구체적인 의미를 가지는 텍스트를 포함하여 작성 시각장애인의 경우에는 웹문서를 탐색할 때 스크린 리더에서 페이지에 있는 링크를 보여주는 ‘링크목록’ 기능을 활용 링크의 title속성은 스크린 리더에서 기본으로 읽어주지 않기 때문에 설정을 바꾸지 않는 한, 사용자는 이 부분을 알지 못하고 지나칠 수 있음 텍스트와 이미지가 동시에 a요소로 마크업 된 경우에는 텍스트 정보만 보여준다. css를 이용하여 아이콘 디자인요소를 나타내면 콘텐츠와 디자인양식을 분리 할 수 있다 이미지 (img) 이미지 개체를 삽입할 때는 빈 요소인 img 요소를 이용 src 속성과 alt 속성은 필수 속성 이미지 맵 (map, area) 클라이언트 사이드 이미지 맵 서버 사이드 이미지 맵 거의 사용하지 않음 목록 관련 요소 → 블록레벨 (★★★★) 비순서형 목록 (u1) 1234&lt;ul&gt; &lt;li&gt; &lt;/li&gt; &lt;li&gt; &lt;/li&gt;&lt;/ul&gt; 순서형 목록 (o1) 1234&lt;ol&gt; &lt;li&gt; &lt;/li&gt; &lt;li&gt; &lt;/li&gt;&lt;/ol&gt; 정의형 목록 (d1) 1234&lt;dl&gt; &lt;dt&gt; &lt;/dt&gt; &lt;dd&gt; &lt;/dd&gt; &lt;/dl&gt; 텍스트 관련 요소 강조 (strong &amp; em) strong요소는 강한 강조 em요소는 강조의 의미 인용문 ( blockquote &amp; q ) blockquote 요소는 블록요소만 포함 q는 인라인요소와 텍스트를 포함 축약어 및 두문자어 ( abbr &amp; acronym ) 추가글 및 삭제글 ( ins &amp; del ) 추가글을 마크업할 땐 ins요소 삭제글을 마크업할 땐 del요소 del요소는 블록 콘텐츠와 인라인 콘텐츠 2가지 다 사용가능 첨자 ( sup &amp; sub ) 테이블 관련 요소 테이블 요소 (table, tr, th, td) 테이블 ( table ) 열 ( columm ) 셀 ( cell ) 행 ( row ) 셀 병합 ( colspan 속성, rowspan 속성 ) 열이 서로 다른 셀을 병합할 때는 colspan 속성을 이용 행이 서로 다른 셀을 병합할 때는 rowspand 속성을 이용 테이블 제목 및 요약문 ( caption &amp; summary ) caption 요소에는 테이블의 내용을 대표할 수 있는 제목을 삽입 summary 속성에는 간단한 제목보다 테이블의 내용을 설명하여 시각적으로 테이블 접근이 쉽지 않음. 열 그룹화 요소 ( colgroup, col ) span 속성을 사용하여 그룹화하려는 열을 지정 colgroup 요소는 논리적인 그룹화를 위해 사용 col 요소는 스타일을 지정할 목적으로 사용 5) 행 그룹화 요소 ( thead, tfoot, tbody ) 헤어행은 thead 요소 푸터행은 tfoot 요소 본문행은 tbody 요소 thead 요소와 tfoot 요소는 테이블에서 한번만 사용가능 행그룹화 요소의 선언 순서: thead, tfoot, tbody 순, colgroup 요소나 col 요소의 다음에 지정. 제목 셀과 내용 셀의 연관성 ( scope, id, headers 속성 ) 폼 관련 요소 폼이란 폼 요소는 웹 문서가 서로 상호작용을 할 수 있도록 하는 역할을 담당 서버 처리와 관련된 프로그램 CGI PHP JSP ASP 폼 요소 ( form ) 폼의 범위를 정의할 때 form 요소를 사용 action = “URI” : 폼의 내용을 처리하기 위한 서버의 URI (필수) method = “get 또는 post” get : action 속성에 지정한 URI에 폼의 내용을 추가하여 서버에 송신하는 방식 post : 폼의 본문으로 송신하는 방식, 데이터의 길이가 긴 경우에 적합 폼 요소 그룹화 및 제목 ( fieldset, legend(지역) ) 여러개의 폼 요소를 그룹화하여 좀 더 구조적으로 만들려면 fieldset요소 사용 fieldset요소를 이용하면 fieldset의 주위에 border가 생성되어 해당 그룹 안에 있는 콘텐츠가 폼과 관련된 컨트롤 요소임을 쉽게 구별가능 legend요소로 fieldset의 컨트롤 등이 어떠한 성격의 콘텐츠인지 제목 형식으로 알려줌 legend요소로 fieldset 요소의 바로 뒤에 한번만 작성 fieldset은 컨트롤 요소 주변에 테두리 설정 legend는 폼 요소의 제목 레이블 ( label ) 폼을 구조화하고 접근성을 높일 수 있는 요소 중에는 label요소가 있다. label 요소는 각 폼 컨트롤의 연관 관계와 설명을 추가하는 역할을 담당함 명시적 label은 id와 for 속성을 연결하기 암묵적 label은 label요소에 폼 컨트롤을 포함시키기 input요소의 id값과 label요소의 for값을 같게 지정 다양한 폼 컨트롤 ( input ) 폼 요소 안에 한 줄 글 상자, 라디오 버튼, 체크 박스 등의 폼 컨트롤을 생성 할 때는 input 요소 사용 type 속성 값에 따라 폼의 종류 결정 1type = “컨트롤 값” text : 한 줄 글상자, 이름, id 등의 컨트롤을 생성 password : 비밀번호입력 상자로, 웹 브라우저 화면에 값을 입력한 값을 ⦁나 *로 표현 radio : 여러 개의 라디오 버튼 중 하나만 선택 checkbox : 다중 선택이 가능한 체크박스 file : 파일을 첨부형태로 서버로 보낼 때 사용하는 컨트롤 image : 이미지 버튼으로 src 속성을 이용하여 버튼 이미지로 사용하려는 이미지를 지정 submit : 전송 버튼 - reset : 취소 버튼 button : 범용버튼 - hidden : 숨긴 컨트롤 목록 상자 ( select, option, optgroup ) select와 option 요소를 이용하여 목록 상자를 생성 드롭다운 메뉴와 리스트 박스로 나눔 여러 줄 글상자 ( textarea ) 여러 줄로 된 텍스트를 입력받을 때는 textarea 요소를 이용 textarea요소는 input요소를 이용한 한 줄 글상자와 달리 textarea 요소를 이용 여러 줄 글상자의 영역 크기는 cols, rows 속성을 이용하여 지정 버튼 요소 ( button ) &lt;-이것보다 a태그를 많이 씀(단점 링크로 읽히는데 버튼임) button요소를 이용하여 생성할 수 있는 경우는 input요소의 submit, reset, button 등의 type값과 같지만, 좀 더 유연한 디자인이 가능하다는 장점 스타일과 스크립트 내부 스타일 적용 ( style ) XHTML 요소 중에서 style요소는 css를 XHTML 문서에 적용할 때 사용 XHTML 요소 중 대부분은 구조를 정의하는 용도로 사용 style 요소는 head에만 지정할 수 있다 스크립트 삽입 ( script ) 웹 문서에 스크립트를 삽입할 때는 script 요소 사용 head 요소와 body 요소에 여러 번 삽입 가능 XHTML의 경우 내용모델이 #PCDATA(Parsed CDATA)이기 때문에 내부 스크립트의 문자 참조(character entity – 특수문자)를 CDATA영역으로 선언하여 처리해야한다. 그룹화 요소 블록 그룹화 요소 (div) div (division) 요소는 분할, 나누기의 의미를 가진다. 그룹핑(grouping)의 역할을 수행 id와 class 속성으로 해당 그룹의 의미를 부여할 수 있다 레이아웃을 구현할 때도 사용할 수 있다 논리적인 구조를 고려하여 서로 연관성 있는 콘텐츠를 그룹핑 하는 것이 좋음 인라인 그룹화 요소 (span) 인라인 요소를 그룹화 할 때는 span요소 사용 id와 class 속성을 이용하여 그룹화한 요소에 적절한 네이밍을 통해 의미를 부여 p요소와 ul요소 같은 블록요소를 포함","categories":[{"name":"HTML / CSS","slug":"HTML-CSS","permalink":"http://yoursite.com/categories/HTML-CSS/"},{"name":"HTML","slug":"HTML-CSS/HTML","permalink":"http://yoursite.com/categories/HTML-CSS/HTML/"}],"tags":[{"name":"HTML / CSS","slug":"HTML-CSS","permalink":"http://yoursite.com/tags/HTML-CSS/"}]},{"title":"CSS","slug":"Css","date":"2017-07-16T09:54:10.000Z","updated":"2017-09-23T14:53:35.000Z","comments":true,"path":"2017/07/16/Css/","link":"","permalink":"http://yoursite.com/2017/07/16/Css/","excerpt":"","text":"css (“casscading style sheet”)마크업 요소에 스타일을 적용하기 위해 W3C에서 고안한 언어 css 서식 선택자 : 스타일을 적용할 대상을 의미 선언부 : 선택자에 적용할 디자인 관련 속성과 값을 의미 css 적용하기 External Style Sheet (외부 스타일 시트) &lt;-이걸 제일 많이 씀. css파일을 독립적으로 생성하여 웹 문서에 삽입하는 방법 @import와 link요소를 이용하여 외부문서로 삽입 구버전의 웹 브라우저에서는 @import를 해석하지 못함 css파일의 첫 줄에 선언 Internal Style Sheet (내부 스타일 시트) HTML 문서 내의 Style요소에 css코드를 포함하는 형식으로 사용 Inline Style Sheet (인라인 스타일 시트) 특정요소에 직접 style 속성을 이용하여 css 스타일을 적용하는 방법 기존 font요소와 크게 차이가 없음 css 선택자선택자는 웹 페이지의 제목, 문단, 링크, 목록, 이미지 등의 HTML 요소들을 선택하는 역할 type 선택자XHTML 요소명을 선택자로 사용하는 것요소 선택자, 태그 선택자로도 불림 전체 선택자* (아스테리스크) 기호를 사용하면 모든 요소에 스타일을 지정할 수 있음유니버셜 선택자라고도 부름1* &#123; css 내용 &#125; class 선택자와 id 선택자XHTML요소에 class나 id 속성을 부여한 경우 해당 class명이나 id명으로 접근 하여 사용 class 선택자 ( 요소명 생략가능 )요소명 . 클래스명 { 속성 : 값 ; } 1p . note &#123; color : gray; &#125; id 선택자 ( 요소명 생략 가능)요소명 # 아이디명 { 속성 : 값 ; } 1ul # gnd &#123; list-style-type : note ; &#125; 속성 (attribute) 선택자XHTML요소가 특정 속성명이나 속성값을 가진 경우 해당 속 성명으로 접근하여 스타일을 적용하는 선택자 방식구버전의 웹 브라우저에서는 지원하지 않는다 요소명 [속성명] : a요소에 target 속성이 있는 경우 요소명 [속성명=“값”] : a요소에 target 속성의 값이 _blank인 경우 요소명 [속성명~=“값”] : a요소에 class 속성의 값이 공백문자로 구분하여 여러개 있는 경우 요소명 [속성명l=“값”] : a요소의 class 속성의 값에 하이픈(-)이 포함된 경우 요소명 [속성명^=“값”] : a요소의 href 속성의 값에 http로 시작하는 경우 요소명 [속성명*=“값”] : a요소의 href 속성의 값에 www가 포함된 경우 가상요소와 가상클래스사용자가 따로 지정할 필요 없이 기본적으로 제공되는 요소와 클래스를 의미특정요소에서 내용의 앞이나 뒤에 가상콘텐츠를 삽입할 때:before가상요소와 :after가상요소를 선택자로 사용할 수 있습니다.:before가상요소와 :after가상요소를 이용 시 content 속성을 사용 가상클래스의 경우 ‘상황에 따라’ 분류하여 스타일 적용 시 a:link, a:visite, a:hover, a:active, a:focus 등을 사용 가상클래스는 선언 순서에 유의해야함 first-line, first-letter 가상요소 first-line선택자는 요소의 첫번째 줄에 있는 콘텐츠만 선택하여 스타일을 지정 first-line선택자를 지정시 웹 브라우저 크기에 따라 유동적으로 스타일 지정 first-letter선택자는 요소의 첫 글자만 선택하여 스타일을 지정 before, after 가상요소 가상의 콘텐츠를 이전이나 이후에 추가할 수 있는 선택자 content 속성에 원하는 문자열을 지정 first-chid 가상클래스 first-child 가상클래스는 첫 번째 자식 요소에만 스타일을 적용 링크 가상 클래스 방문하지 않은 링크 (:link) -1 방문한 링크 (:visited) -2 마우스를 올려놨을 경우 (:hover) -3 활성화 되었을 경우 (:active) -4 포커스가 생긴 경우 (:focus) -5 순서는 1부터 5순서이다 선택자 조합 하위 선택자상위요소가 포함하고 있는 모든 하위요소에 스타일을 지정할 때 사용선택자 선택자 { 속성 : 값 : } - 선택자와 선택자 사이에 공백 1div p &#123; color : gray ; &#125; 자식 선택자부모 요소의 바로 다음에 있는 자식 요소에 스타일을 적용하는 방법선택자 &gt; 선택자 { 속성 : 값 ; } - 선택자와 선택자 사이에 부등호(&gt;) 사용 1div &gt; p &#123; color : gray ; &#125; 인접 형제 선택자처음 등장하는 요소를 형 요소, 뒤에 등장하는 요소를 동생요소형 요소 다음에 오는 동생 요소에 스타일을 적용할 때 사용선택자 + 선택자 { 속성값 : 값 ; } - 선택자와 선택자 사이에 (+)로 구분 1h1 + h2 &#123; color : gray ; &#125; 선택자 그룹화다수의 요소에 똑같은 선언을 지정할 경우 선택자를 그룹화하여 사용선택자를 그룹화 할 때 콤마(,) 사용1선택자 , 선택자 &#123; 속성 : 값 ; &#125; css 개념 및 단위상속 상위 요소에 적용한 스타일이 하위 요소까지 이어지는 현상 일부는 상속의 대상에서 제외 border 속성의 경우 p요소에 상속되지 않음 div요소 하위에 p요소와 body요소 하위에 있는 p요소의 글자크기가 상속 때문에 다르게 출력 겹침과 개별성 css는 ‘단계적으로 적용되는 스타일’을 의미 c의 cascading은 ‘단계적’이라는 의미 가장 마지막에 선언한 스타일을 우선적으로 적용 주석 및 단위와 색상 주석/* 내용 */를 사용불필요한 주석은 버그를 유발하기 때문 삽입하지 않는다. 단위‘절대단위’와 ‘상대 단위’가 있음절대단위: pt(포인트), cm, mm, pc(파이카), in(인치)상대단위: px(픽셀) - 해상도를 기준으로 크기가 결정ex단위 – 소문자 x를 기준으로 크기가 결정em – front-size 값을 기준으로 크기 정함%(백분율) 색상색상 적용 방식 – 색상명, 16진수 코드 방식 css속성박스모델 width: 콘텐츠의 가로 크기 height: 콘텐츠의 세로 크기 border: 콘텐츠 테두리 margin: 콘텐츠 바깥쪽 여백 (border 기준) padding: 콘텐츠 안쪽 여백 (border 기준) 박스 너비와 높이 width(너비)와 height(높이) 속성은 박스의 크기를 지정하는 속성 테두리 (border)콘텐츠에 테두리를 지정할 때는 border와 관련된 속성을 사용선 모양(border-style), 선 굵기(border-width), 선 색상(border-color)박스의 위쪽(border-top), 왼쪽(border-left), 오른쪽(border-right),아래쪽(border-bottom)border-style의 속성값 none - hidden - dotted - dashed - solid double - groove - ridge - inset - outset 마진 (margin)블록요소와 블록요소 사이를 구분하는 빈 공간을 의미함border를 기준으로 바깥쪽 영역의 여백을 의미마진은 박스의 위쪽, 아래쪽, 오른쪽, 왼쪽을 서로 다르게 지정할 수 있음 패딩 (padding)border를 기준으로 안쪽 영역의 여백을 의미 플로트 (float)float박스의 위치를 부모 요소의 안에서 왼쪽 또는 오른쪽으로 이동시키는 기능float : left / right / none / inherit clear블록요소나 블록요소를 대체할 수 있는 속성을 지정한 경우에만 사용 가능clear : left / right / none / inherit 포지션 (position)박스에 대한 배치를 변경할 때 사용하는 속성 position : static / relative / absolute / fixed / inherit top : 길이 / 퍼센트 / auto / inherit right : 길이 / 퍼센트 / auto / inherit bottom : 길이 / 퍼센트 / auto / inherit left : 길이 / 퍼센트 / auto / inherit relative positionrelative 방식은 ‘상대 배치 방식’요소가 본래 있었던 자신의 위치를 기준으로 지정한 오프셋 속성의 값만큼 떨어져서 배치되는 방식1position : relative; absolute positionabsolute방식은 ‘절대 배치 방식’요소가 포함된 컨테이닝 블록을 기준으로 지정한 오프셋 속성의 값만큼떨어져서 배치되는 방식 레이어(layer)라고 부름 absolute의 컨테이닝 블록은 상위요소가 모두 static이면 body를 기준으로 배치 1position : absolute; 컨테이닝 블록이 body요소일 경우absolute로 지정한 요소의 상위요소가 position : static (기본값)이거나 body일 때는 absolute로, 지정한 요소의 오프셋은 body요소를 기준으로 배치 컨테이닝 블록이 position : relative일 경우absolute로 지정한 요소의 상위요소가 position : relative이거나position : absolute일 때 오프셋은 body요소가 아닌 absolute의 컨테이닝블록을 기준으로 배치 fixed position배치는 absolute로 지정한 요소의 배치와 유사스크린 기준으로 배치fixed로 지정한 요소는 항상 같은 위치에 배치오프셋을 지정하는 방법은 다른 요소와 동일하며 top, right, bottom, left기준 모두 사용가능 타이포 그래피font-family웹 문서의 글꼴을 지정할 때 사용글꼴은 콤마(,)로 구별한다지정순서로 글꼴의 우선순위 결정콤마로 구분하여 여러 개로 지정하는 글꼴을 ‘글꼴패밀리’라 한다글꼴패밀리를 지정 후 마지막에는 대표 패밀리를 명시해야 함대표패밀리 : serif, sans-serif, cursive, fantasy, monospace대표패밀리는 키워드이기 때문에 인용부호로 묶지 않음 font-size웹 문서의 글자크기를 지정할 때 사용‘절대크기’와 ‘상대크기’절대단위: xx-small, x-small, small, medium, large, x-large, xx-large, pt, pc, cm, mm 등의 단위로 사용상대단위: px, em, ex, 퍼센트 형식font-size: 키워드/ 길이 / 퍼센트 / inherit1234font-size : small ;font-size : 12px ;font-size : 1.5em ;font-size : 150% ; line-height문단의 행간을 지정할 경우 사용글자의 위쪽과 아래쪽 여백을 ‘반행간(half-leading)’line-height : normal / 실수 / 길이 / 퍼센트 / inherit ;1234line-height : normal ;line-height : 1.6 ;line-height : 1.5em ;line-height : 200% ; font-weight글꼴을 굵게 장식할 때normal, bold, bolder, lighter 등의 키워드, 100~900까지 9단계의 값123font-weight : 키워드 / 100~900 / inherit ;font-weight : bold ;font-weight : 400 ; font-style글꼴의 스타일을 지정할 때 사용normal, italic, ablique1font-style : normal / italic / ablique ; font-variant영문 글꼴의 소문자를 대문자로 변경할 때normal이나 small-caps중 하나의 값을 적용small-caps 적용시 소문자를 대문자로 변형크기는 대문자 크기와 다르게 ‘크기가 작은 대문자’로 출력1font-variant : normal / small-caps ; fontfont-family, font-size, line-height, font- weight, font- style,font-variant, font속성을 이용하여 단축표현을 할 수 있음단축표현을 할 때 순서를 지켜야함1font : [font-weight / font-style / font- variant] / [font-size] / [/line-height] / [font-family] text-indent문서를 작성할 때 사용하는 텍스트 관련 서식 중에는 단락 첫 번째 줄 들여 쓰기 기능과 같은 것단락 첫 번째 줄 들여쓰기 효과를 적용할 수 있음음수 값을 지정하여 첫 번째 줄 내어쓰기 효과도 적용1text-ident: 길이 / 퍼센트 / inherit text-align텍스트를 가로 기준으로 정렬할 때 사용left, center, right 정렬은 일반 문서 작성기에서 사용하는 단락정렬기능과 똑같이 동작justify는 양쪽 정렬을 의미, 양쪽정렬이 웹 브라우저에 따라 다르게 동작할 수 있음left, center, right, justify 등의 값을 사용1text-align : left / center / right / justify / inherit vertical-alignHTML에서 나 , 이나 과 같이 윗첨자와 아랫첨자를 적용하거나 테이블에서 셀의 텍스트를 수직위치를 정렬할 때 사용인라인요소와 이미지요소, input요소 등에 적용블록요소의 경우 사용할 수 없음테이블 관련요소 th와 td요소는 사용가능1vertical-align : baseline / sub / super / top / text-top / middle / bottom / text-bottom / 길이 / 퍼센트 / inherit 테이블의 셀(th요소나 td요소)에 vertical-align을 적용할 경우 baseline, top, middle, bottom 값만 인정 text-decoration텍스트에 밑줄을 긋거나 취소선 등의 효과를 적용할 때 사용blink는 텍스트를 깜박거리게 하는 기능, 대다수의 브라우저에서 지원하지 않음1text-decoration : none / underline / overline / line-through / blink / inherit text-transform영문 대소문자를 변경할 때 사용기본값은 none대문자는 소문자로, 소문자는 대문자로, 또는 단어의 첫 글자를 대문자로 변환1text-transform : none / uppercase / lowercase / capitalize / inherit 주로 px, em 단위를 많이 사용 white-space공백문자를 처리하는 방식을 결정하는 속성입력할 형태 그대로 출력 { white-space : pre ; }자동 줄바꿈을 허용하지 않을 경우 { white-space : nowrap ; }pre-wrap, pre-line요소는 대부분의 브라우저에서 사용 안함1white-space: normal / nowrap / pre / pre-wrap / pre-line / inherit 색상과 배경color요소의 텍스트 색상을 설정할 때 사용color : 색상명 / RGB 16진수 / RGB 10진수 / RGB 백분율 / inherit1&#123; color : 색상명 ; &#125; background-color요소의 배경색을 설정할 때 사용background-color : 색상명 / RGB 16진수 / RGB 10진수 / RGB 백분율 background-image요소의 배경이미지를 설정할 때 사용마크업에서는 배경이미지를 body요소와 table의 일부의 요소에만 사용가능, css에서는 모든 요소에 적용1background-image : none / uri() / inherit background-repeat요소에 지정한 배경이미지의 반복 여부를 변경할 때 사용기본값이 repeat이기 때문에 배경 이미지는 항상 반복해서 출력1background-repeat : repeat/ repeat-x/ repeat-y/ no-repeat/ inherit background-position요소에 지정한 배경 이미지의 위치를 변경할 때 사용1background-position : left/ right/ center/ top/ bottom/ 길이/ 퍼센트 background-attachment요소에 지정된 배경이미지를 항상 같은 위치에 고정시킬 때 사용1backgroung-attachment : scroll / fixed / inherit backgroundbackground속성과 관련된 5가지 속성을 단축해서 사용가능배경과 관련된 속성값을 한번씩만 순서에 관계없이 선언1background : background-color/ background-image/ background-repeat/ background-position / background-attachment/ inherit 목록list-style-type목록을 생성할 때 기본적으로 제공되는 마커를 변경할 때 사용1list-style-type : none / disc/ circle/ square/ decimal/ decimal-leading-zero/ upper-alpha/ lower-alpha/ upper-roman/ lower-roman/ upper-latin/ lower-latin/ lower-greek/ armenian/ georgian/ inherit none : 목록마커를 사용하지 않음 disc : 검은색 원 모양의 마커 circle : 내부가 비어 있는 원 모양의 마커 square : 검은색 사각형 모양의 마커 decimal : 1,2,3형식의 아라비아 숫자 decimal-leading-zero : 01,02,03형식의 아라비아 숫자 upper-alpha, upper-latin : A,B,C형식의 알파벳 대문자 lower-alpha, lower-latin : a,b,c형식의 알파벳 소문자 upper-roman : I, II, III 형식의 로마자 대문자 lower-roman : I, ii, iii 형식의 로마자 소문자 lower-greek : 소문자의 그리스 숫자 형식 armenian : 고대 아르메니안 숫자 형식 georgian : 고대 조지안 양식의 숫자 형식 list-style-position목록의 각 항목(list item)에 있는 목록 마커를 목록 안쪽에 나타낼 것인지, 바깥쪽에 나타낼 것인지 결정1list-style-position : inside/ outside/ inherit 기본 속성은 outside list-style-image목록마커 대신 이미지를 사용할 때1list-style-image : url() / none/ inherit 기타 속성border-collapse테이블의 border를 표시하는 방법을 결정할 때 사용separate의 경우 border의 분리 방식을 의미, 인접해 있는 각 셀마다 각각 border를 갖도록 한다.collapse는 병합방식을 의미, 인접한 각 셀들은 하나의 border를 합쳐서 표시1border-collapse : separate/ collapse/ inherit overflow콘텐츠가 블록박스의 크기를 넘어가는 경우에 사용기본 값은 visible1overflow : visible / hidden / scroll / auto / inherit display요소가 가지고 있는 박스의 성격(블록요소 또는 인라인요소)을 변경할 때 사용박스를 감출 때 { display : none ; }1display : none/ block/ inline/ inline-block/ inherit visibility요소박스를 표시하거나 감출 때 사용visibility : hidden ; 형식으로 박스를 감출 경우 박스가 생성되어 있고 유효, 화면에서만 보이지 않도록 투명하게 한다.1visibility : visible / hidden / inherit z-index요소박스가 겹쳐지는 순서를 지정할 때 사용1z-index : auto / 정수 (1,2,3,4,…) css hack문제를 바로잡기 위한 트릭이나 꼼수를 핵(hack) 또는 필터(filter) ※ HTML 필터 (*html filter) 필터를 사용하면 css의 유효성 검사를 통과할 수 없다.1*html p &#123; color : red ; &#125; ※ 언더스코어 핵 (underscore hack) 속성명 앞에 언더스코어(_)를 붙이면 인터넷 익스플로어 4~6에만 스타일이 적용1p &#123; _color : red ; &#125; ※ 해시 핵 (hash hack) 속성명 앞에 샾(#)을 붙이면, 인터넷 익스플로러 4~7에만 스타일 적용1p &#123; #color : red ; &#125; ※ 조건 주석문 ( conditional comment) 인터넷 익스플로러에만 사용 할 수 있는 핵으로 기존의 주석문을 다르게 해석하도록 확장한 비표준 방식","categories":[{"name":"HTML / CSS","slug":"HTML-CSS","permalink":"http://yoursite.com/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"http://yoursite.com/categories/HTML-CSS/CSS/"}],"tags":[{"name":"HTML / CSS","slug":"HTML-CSS","permalink":"http://yoursite.com/tags/HTML-CSS/"}]},{"title":"웹 접근성 / W3C","slug":"Web","date":"2017-07-16T09:54:10.000Z","updated":"2017-09-23T13:34:48.000Z","comments":true,"path":"2017/07/16/Web/","link":"","permalink":"http://yoursite.com/2017/07/16/Web/","excerpt":"","text":"웹 접근성 (웹 사이트에서 제공하는 정보를 차별 및 제한없이 동등하게 이용 할 수 있도록 보장하는 것) 모든 사용자가 신체적, 환경적 조건에 관계없이 웹에 접근하여 이용 신체적 조건 일반 사용자 장애를 가진 사람 고령자 환경적 조건 다양한 기기 (PC, Mobile, PDA 등) ⦁ OS(운영체제) 웹 브라우저 저 사양 및 저속회선 사용자 이미지, 동영상을 볼 수 없는 환경 웹은 단기간, 다양한 환경, 다양한 사람들이 정보를 공유하는 공간 웹 접근성은 웹이 가져야할 당연한 개념 장애인, 고령자 등을 포함한 사용자층 확대 규정과 법적 요구 사항에 대한 준수 장애인 파별 금지 및 권리구제 등에 관한 법률 동법 시행령 다양한 환경, 새로운 기기에서의 이용 모바일 다양한 OS 및 웹 브라우저의 사용범위 확대 개발 및 운용의 효율성 제고 다양한 환경을 고려 제작 및 운용의 효율성 사회 공헌 및 복지 기업으로서의 기업 이미지 향상 웹 콘텐츠 접근성 지침① 인지성② 이해성③ 운용성④ 내구성 장애인 차별 금지 및 권리 구제 등에 관한 법률의 이해 의무적으로 웹 접근성을 준수해야 함. W3C(World Wide Web Consortium)역할 정보 의견 교환 아이디어 창출 독립적 사고 소프트웨어 공동의 이해를 위하여 명세 가이드라인 도구 및 규칙 등 W3C in 7 Point 광역 접근성(★) 시맨틱 웹 신용 상호 운영성 진화 분산화 멋있는 멀티미디어 웹 표준 (Web Standards) 웹에서 표준적으로 사용되는 기술이나 규칙 웹 표준 관련 기술 웹 표준의 장점 웹 접근성 수준의 향상 웹 표준을 준수하는 것만으로도 웹 접근성이 향상 검색 친화적인 웹 사이트 구현 meta요소를 이용한 정확한 문서정보의 제공과 적절한 제목(heading 요소)의 사용 의미에 맞는 마크업은 검색 시 결과에 영향을 미칠 수 있는 중요한 정보 충실하게 작성된 문서 정보만으로도 검색의 효율성을 높임 구조와 표현의 분리 구조는 HTML이나 XHTML 등의 마크업 언어를 구축 디자인과 같은 표현정보는 CSS를 이용 구조와 표현이 분리된 독립적인 구현이 가능 손쉬운 유지 보수 및 비용 절감 효과 구조와 표현을 분리하여 제작하면 유지보수 시 많은 이점 리뉴얼을 위한 디자인만 변경하고자 할 경우 기존의 마크업 코드는 그대로 재사용하고 디자인을 위한 CSS코드만을 재작성 구조와 표현을 분리했을 때, 소스의 경량화로 인해 서버의 트래픽 비용이 감소하는 부수적인 효과를 얻음 호환성을 확보 마크업과 CSS 웹 브라우저와 웹 표준 웹 브라우저(사용자가 웹 서버의 하이퍼텍스트 문서를 볼 수 있도록 해주는 클라이언트 프로그램을 말함) 웹 브라우저의 종류 인터넷 익스플로러(8~11) 오페라 구글 크롬 파이어 폭스 사파리","categories":[{"name":"웹 접근성","slug":"웹-접근성","permalink":"http://yoursite.com/categories/웹-접근성/"}],"tags":[{"name":"웹 접근성","slug":"웹-접근성","permalink":"http://yoursite.com/tags/웹-접근성/"},{"name":"W3C","slug":"W3C","permalink":"http://yoursite.com/tags/W3C/"}]}]}